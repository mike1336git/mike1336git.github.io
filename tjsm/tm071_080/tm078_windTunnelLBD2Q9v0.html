<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>tm078_windTunnelLBD2Q9</title>
  <!--
  <script src="../lib/three.min.js"></script>
  <script src="../lib/OrbitControls.js"></script>
  <script>
  -->
	<style type="text/css">
		body { color:#000000; background-color:#fff8dd; }
	</style>

	<style type="text/css">
		.lil-gui {
			--width: 300px;
			--name-width: 30%;
		}
	</style>

	<script type="importmap">
		{
			"imports": {
				"three": "../libm/three.module.js",
				"orb": "../libm/OrbitControls.js",
				"lil-gui": "../libm/lil-gui.module.min.js"
			}
		}
	</script>


<!-- %%%%%%%%%%%%%%%%%%%%  javaScript  %%%%%%%%%%%%%%%%%%%% -->

<script type="module">

import * as THREE from 'three';
import { OrbitControls } from 'orb';
import { GUI } from 'lil-gui';


'use strict';

/* =================================================================================================================
//
//  tm078_windTunnelLBD2Q9
//    Copyright(C) 2023 Mitsuru Ikeuchi
//    Released under the MIT license ( https://opensource.org/licenses/MIT ) 
//
//    ver 0.0.0  2023.02.02 created, last updated on 2023.02.03
//
//
//------------------------------------------------------------------------------------------------------------------
//
//  Lattice Boltzmann Method - D2Q9 model
//
//    D2Q9 model - velocity distribution in lattice i,j:
//       velocity base vectors:
//          e[0]=[ 0, 0], e[1]=[ 1, 0], e[2]=[ 0, 1], e[3]=[-1, 0], e[4]=[ 0,-1],
//          e[5]=[ 1, 1], e[6]=[-1, 1], e[7]=[-1,-1], e[8]=[ 1,-1]
//       velocity distribution at lattice i,j: fv[i][j][k]*e[k], k=0,1,2,...,8
//
//      (1) set lattice:
//          density: rho[i][j],
//          flow velocity: ux[i][j],uy[i][j]
//          velosity distribution: f[i][j][k] (k=0,1,2,...,8)
//
//      (2) streaming  f(r+ek*dt,t+dt) = f(r,t)
//         ftx[i][j][0] <-- ftp[i][j][0]      // 0:(0,0)
//         ftx[i][j][1] <-- ftp[i-1][j][1]    // 1:E(1,0)
//         ftx[i][j][2] <-- ftp[i][j-1][2]    // 2:N(0,1)
//         ftx[i][j][3] <-- ftp[i+1][j][3]    // 3:W(-1,0)
//         ftx[i][j][4] <-- ftp[i][j+1][4]    // 4:S(0,-1)
//         ftx[i][j][5] <-- ftp[i-1][j-1][5]  // 5:NE(1,1)
//         ftx[i][j][6] <-- ftp[i+1][j-1][6]  // 6:NW(-1,1)
//         ftx[i][j][7] <-- ftp[i+1][j+1][7]  // 7:SW(-1,-1)
//         ftx[i][j][8] <-- ftp[i-1][j+1][8]  // 8:SE(1,-1)
//
//      (3) scattering  f(r,t+dt) = f(r,t+dt) - omega*(f(r,t+dt)-feq))
//         rho = sigma(f[i][j][k], k=0,1,2,...,8)
//         vx = sigma(e[k][0]*f[i][j][k], k=0,1,2,...,8)/rho
//         vy = sigma(e[k][1]*f[i][j][k], k=0,1,2,...,8)/rho
//         feq[k]: equilibrium velocity distribution (rho*u = sum(feq[k]*e[k],k=0,...8)
//                 feq[k] = w[k]*rho(r)*(1+3*(e[k].u)+4.5*(e[k].u)^2-1.5u^2) (D2Q9 at c=dx/dt=1)
//         f[i][j][k] = f[i][j][k] - omega*(f[i][j][k]-feq[k])
//           omega = 1/tau = 1/(3*kineticViscosity+0.5),(2D,dx=1,dt=1). tau:relaxation time
//
//         at boundary
//           wall: bounce-back ( E <--> W, N <--> S, NE <--> SW, NW <--> SE )
//           velocity boundary: set rho,ux,uy and feq
//
//      goto (2)
//
//
//------------------------------------------------------------------------------------------------------------------
*/

const windTunnelLBD2Q9 = (function(){ //========================  windTunnelLBD2Q9 Module  =========================

	const gc_NNxMax = 540;			// maximum array x-size of field
	const gc_NNyMax = 180;			// maximum array y-size of field

	var g_sysTime = 0.0;			// system time
	var g_dt = 1.0;					// time step
	var g_dx = 1.0;					// x-division
	var g_dy = 1.0;					// y-division
	var g_tpp = 0;					// present time v9[tpp][i][j], tpp = 0 or 1 
	var g_tnx = 1;					// next    time v9[tnx][i][j], tnx = 1 or 0
	var g_status = 'STABLE';		// system status (in string)

	var g_themeNum = 0;				// theme mnumber 0 - 6
	var g_themeStr = "theme";		// theme eg. "gas expansion"
	var g_NNx = 270;				// array x-size of field
	var g_NNy = 90;					// array y-size of field
	var g_drawScale = 2;			// draw scale
	var g_vxBoundary = 0.1;			// periodic condition : vx=0.1 (sound speed = 1.0) at x=0
	var g_vyBoundary = 0.0;			// periodic condition : vy=0.0 (sound speed = 1.0) at x=0
	var g_objectLength = 10.0;		// objectLength  Re = (vxFlow/nue)*objectLength

	var g_xCanvasSize = 600;		// in pixel
	var g_yCanvasSize = 240;		// in pixel
	var g_canvas = null;			// canvas ptr
	var g_ctx = null;				// = canvas.getContext('2d');

	var g_imageData;				// display image data pointer = ctx.getImageData(20, 20, 360, 360);
	var g_xProbe = 540/2;			// probe position x
	var g_yProbe = 180/2;			// probe position y

	//           0    1    2    3    4    5    6    7    8
	//var feq = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]; // equilibrium velocity distribution
	var g_kind = dimInt2(gc_NNxMax,gc_NNyMax);		// kind[ix][iy] 0:free space,1:wall,2:velocity boundary
	var g_v9 = dim4(2,gc_NNxMax,gc_NNyMax,9);		// velocity distribution v9[tpp/tnx][ix][iy][0-8]
	var g_rho = dim2(gc_NNxMax,gc_NNyMax);			// density rho[ix][iy]
	var g_ux = dim2(gc_NNxMax,gc_NNyMax);			// x-component of flow velocity (sound speed = 1.0)
	var g_uy = dim2(gc_NNxMax,gc_NNyMax);			// y-component of flow velocity (sound speed = 1.0)

	var g_hue = dimInt2(3,371);
	var g_hueColor = [];

	(function() {
		var deg,x;

		for (deg=0; deg<361; deg++) {
			if (deg<60) {
				x = deg;
				g_hue[0][deg] = 255;
				g_hue[1][deg] = Math.floor(255.0*x/60.0);
				g_hue[2][deg] = 0;
			} else if (deg<120) {
				x = deg-60;
				g_hue[0][deg] = Math.floor(255.0*(60.0-x)/60.0);
				g_hue[1][deg] = 255;
				g_hue[2][deg] = 0;
			} else if (deg<180) {
				x = deg-120;
				g_hue[0][deg] = 0;
				g_hue[1][deg] = 255;
				g_hue[2][deg] = Math.floor(255.0*x/60.0);
			} else if (deg<240) {
				x = deg-180;
				g_hue[0][deg] = 0;
				g_hue[1][deg] = Math.floor(255.0*(60.0-x)/60.0);
				g_hue[2][deg] = 255;
			} else if (deg<360) {
				x = deg-240;
				g_hue[0][deg] = Math.floor(255.0*x/120.0);
				g_hue[1][deg] = 0;
				g_hue[2][deg] = Math.floor(255.0*(120.0-x)/120.0);
			} else {
				g_hue[0][deg] = 0; g_hue[1][deg] = 0; g_hue[2][deg] = 0;
			}

			g_hueColor[deg] = 'rgb('+g_hue[0][deg]+','+g_hue[1][deg]+','+g_hue[2][deg]+')';
		}
	}());

	function dim2(ni,nj) {
		var i,j, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = 0.0;
			}
		}
		return a;
	}

	function dimInt2(ni,nj) {
		var i,j, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = 0;
			}
		}
		return a;
	}

	function dim4(ni,nj,nk,nl) {
		var i,j,k,l, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = [];
				for (k=0; k<nk; k++) {
					a[i][j][k] = [];
					for (l=0; l<nl; l++) {
						a[i][j][k][l] = 0.0;
					}
				}
			}
		}
		return a;
	}


 	//--------------------  set theme and user parameter  --------------------

	var g_themeParam = [
		// 0:themeStr            1:NNx 2:NNy 3:sc 4:nue 5:vxFan 6:rhoMag
		["wind tunnel(540x180)", 540,  180,  1,   0.02, 0.100, 30.0  ],
		["wind tunnel(270x90)",  270,   90,  2,   0.02, 0.100, 30.0  ],
		["wind tunnel(180x60)",  180,   60,  3,   0.02, 0.100, 30.0  ],
		["wind tunnel(135x45)",  135,   45,  4,   0.02, 0.100, 30.0  ]
	];

	var g_userParam = {
		powderON : true, //false,
		probeON : false,
		nue : 0.02,
		vxFlow : 0.10,
		rhoMag : 1.0
	};

	function setThemeAndUserParam(theme) {
		g_themeNum = theme;
		g_themeStr = g_themeParam[theme][0];
		g_NNx = g_themeParam[theme][1];
		g_NNy = g_themeParam[theme][2];
		g_drawScale = g_themeParam[theme][3];
		g_userParam.nue = g_themeParam[theme][4];
		g_userParam.vxFlow = g_themeParam[theme][5];
		g_userParam.rhoMag = g_themeParam[theme][6];
	}


	//--------------------  set initial condition  --------------------

	function setInitialCondition( theme, objectNum ) {
		
		g_imageData = null;
		g_status = 'STABLE';
		g_sysTime = 0.0;
		setThemeAndUserParam(theme);
		g_vxBoundary = g_userParam.vxFlow;
		setInitialLattice(theme,objectNum);
		powder.setInitialPosition(); // powder
	}

	// objectNum
	function setInitialLattice(theme,objectNum) {
		// objectNum: 0:plate, 1:square, 2:circle, 3:triangle, 4:rtiangle2
		var i,j,nnx=g_NNx,nny=g_NNy, rh,vx,vy, i0=Math.floor(0.2*g_NNx),j0=Math.floor(0.5*g_NNy),a,r;

		// free space: g_kind[][] = 0
		rh = 1.0;
		vx = g_userParam.vxFlow;
		vy = 0.0;
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				g_kind[i][j] = 0;
				setEquiLattice(g_v9[g_tpp][i][j], rh, vx, vy, i, j);
			}
		}

		// set wall g_kind[][] = 1
		a = Math.floor(0.1*nny*g_dy);
		g_objectLength = 2*(a-1);
		if (objectNum==0) { // 0:plate
			for (j=j0-a; j<j0+a; j++) {
				setWall(i0,j);
			}
		} else if (objectNum==1) { // 1:square
			for (i=i0-a; i<i0+a; i++) {
				for (j=j0-a; j<j0+a; j++) {
					setWall(i,j);
				}
			}
		} else if (objectNum==2) { // 2:circle
			for (i=i0-a; i<i0+a; i++) {
				for (j=j0-a; j<j0+a; j++) {
					if ((i-i0)*(i-i0)+(j-j0)*(j-j0)<a*a-0.5) setWall(i,j);
				}
			}
		} else if (objectNum==3) { // 3:triangle
			for (i=i0-a; i<i0+a; i++) {
				for (j=j0-a; j<j0+a; j++) {
					if ((i-i0)<=(j-j0)) setWall(i,j);
				}
			}
		} else if (objectNum==4) { // 4:triangle2
			for (i=i0-a; i<i0+a; i++) {
				for (j=j0-a; j<j0+a; j++) {
					if ((i-i0)>=(j-j0)) setWall(i,j);
				}
			}
		}

		// set velocity boundary: g_kind[][] = 2
		rh = 1.0;
		vx = g_userParam.vxFlow;
		vy = 0.0;
		for (j=0; j<nny; j++) {
			g_kind[0][j] = 2;
		}
		for (i=1; i<nnx; i++) {
			g_kind[i][0] = 2;
		}
	}

	/*
	function setWall(i,j) {
		g_kind[i][j] = 1;
		setEquiLattice(g_v9[g_tpp][i][j], 0.0, 0.0, 0.0, i, j);
	}
	*/

	function setWall(i,j) {
		g_kind[i][j] = 1; // wall
		for (var k=0; k<9; k++) {
			g_v9[g_tpp][i][j][k] = 0.0;
		}
	}


	//--------------------  time evolution  --------------------

	function timeEvolution( nue, flowVx, nCalc ) {
		var i;

		if (g_status=='STABLE') {
			g_userParam.nue = nue;
			g_userParam.vxFlow = flowVx;
			g_vxBoundary = flowVx;
			for (i=0; i<nCalc; i++) {
				streaming();
				scattering(g_userParam.nue);
				if (g_userParam.powderON) powder.move(); // powder
				if (g_status != 'STABLE') break;
				g_sysTime += g_dt;
				g_tpp = g_tnx;
				g_tnx = (g_tnx+1)%2;
			}
		}
		return g_status;
	}

	//--- (2) streaming

	function streaming() {
		var i,j,ip,im,jp,jm,nnx=g_NNx,nny=g_NNy, fij;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				ip = (i+1)%nnx; 
				im = (i-1+nnx)%nnx;
				jp = (j+1)%nny;
				jm = (j-1+nny)%nny;
				fij = g_v9[g_tnx][i][j];
				fij[0] = g_v9[g_tpp][i][j][0];   // 0:(0,0)
				fij[1] = g_v9[g_tpp][im][j][1];  // 1:E(1,0)
				fij[2] = g_v9[g_tpp][i][jm][2];  // 2:N(0,1) 
				fij[3] = g_v9[g_tpp][ip][j][3];  // 3:W(-1,0)
				fij[4] = g_v9[g_tpp][i][jp][4];  // 4:S(0,-1)
				fij[5] = g_v9[g_tpp][im][jm][5]; // 5:NE(1,1)
				fij[6] = g_v9[g_tpp][ip][jm][6]; // 6:NW(-1,1)
				fij[7] = g_v9[g_tpp][ip][jp][7]; // 7:SW(-1,-1)
				fij[8] = g_v9[g_tpp][im][jp][8]; // 8:SE(1,-1)
			}
		}
	}

	//--- (3) scattering

	/*
	function scattering(kineticViscosity) {
		var i,j,k,nnx=g_NNx,nny=g_NNy, omega,fij,rh,vx,vy,m;

		omega = 1.0/(3.0*kineticViscosity+0.5);
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				fij = g_v9[g_tnx][i][j];
				if (g_kind[i][j]==0) { // free space
					rh = fij[0]+fij[1]+fij[2]+fij[3]+fij[4]+fij[5]+fij[6]+fij[7]+fij[8];
					if (rh>=0) {
						vx = (fij[1]-fij[3]+fij[5]-fij[6]-fij[7]+fij[8])/rh;
						vy = (fij[2]-fij[4]+fij[5]+fij[6]-fij[7]-fij[8])/rh;
						setEquiLattice(feq, rh, vx, vy, i, j)
						for (k=0; k<9; k++) {
							fij[k] -= omega*(fij[k]-feq[k]);
						}
					} else {
						g_status = "UNSTABLE at i="+i+",j="+j+",rho="+rh.toFixed(3)+"<br>"+
									"change kinetic viscosity or fan vx and press reset";
					}
				} else if (g_kind[i][j]==1) { // wall: bounce-back boundary
					fij[0] = 0.0;
					m = fij[1]; fij[1] = fij[3]; fij[3] = m; // 1:E(1,0) 3:W(-1,0)
					m = fij[2]; fij[2] = fij[4]; fij[4] = m; // 2:N(0,1) 4:S(0,-1)
					m = fij[5]; fij[5] = fij[7]; fij[7] = m; // 5:NE(1,1) 7:SW(-1,-1)
					m = fij[6]; fij[6] = fij[8]; fij[8] = m; // 6:NW(-1,1) 8:SE(1,-1)
				}
			}
		}
	}
	*/

	function scattering(kineticViscosity) { // faster than above
		var i,j,k,nnx=g_NNx,nny=g_NNy, omega,fij,rh,vx,vy,m;
		var w0=4.0/9.0,w1=1.0/9.0,w2=1.0/36,ux3,uy3,ux2,uy2,uxuy2,u2,c0;

		omega = 1.0/(3.0*kineticViscosity+0.5);
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				fij = g_v9[g_tnx][i][j];
				if (g_kind[i][j]==0) { // free space
					rh = fij[0]+fij[1]+fij[2]+fij[3]+fij[4]+fij[5]+fij[6]+fij[7]+fij[8];
					if (rh>0) {
						vx = (fij[1]-fij[3]+fij[5]-fij[6]-fij[7]+fij[8])/rh;
						vy = (fij[2]-fij[4]+fij[5]+fij[6]-fij[7]-fij[8])/rh;
						g_rho[i][j] = rh;
						g_ux[i][j] = vx;
						g_uy[i][j] = vy;
						// fij[k] -= omega*(fij[k]-feq[k]);
						// feq[k] = wk*rho*(1+3*(ek.u)+4.5*(ek.u)^2-1.5u^2) (D2Q9 at c=dx/dt=1)
						ux3 = 3.0*vx;
						uy3 = 3.0*vy;
						ux2 = vx*vx;
						uy2 = vy*vy;
						uxuy2 = 2.0*vx*vy;
						u2 = ux2 + uy2;
						c0 = 1.0 - 1.5*u2;
						fij[0] += omega*(w0*rh * (c0                              )-fij[0]); // 0(0,0)
						fij[1] += omega*(w1*rh * (c0 + ux3       + 4.5*ux2        )-fij[1]); // E(1,0)
						fij[2] += omega*(w1*rh * (c0       + uy3 + 4.5*uy2        )-fij[2]); // N(0,1)
						fij[3] += omega*(w1*rh * (c0 - ux3       + 4.5*ux2        )-fij[3]); // W(-1,0)
						fij[4] += omega*(w1*rh * (c0       - uy3 + 4.5*uy2        )-fij[4]); // S(0,-1)
						fij[5] += omega*(w2*rh * (c0 + ux3 + uy3 + 4.5*(u2+uxuy2) )-fij[5]); //NE(1,1)
						fij[6] += omega*(w2*rh * (c0 - ux3 + uy3 + 4.5*(u2-uxuy2) )-fij[6]); //NW(-1,1)
						fij[7] += omega*(w2*rh * (c0 - ux3 - uy3 + 4.5*(u2+uxuy2) )-fij[7]); //SW(-1,-1)
						fij[8] += omega*(w2*rh * (c0 + ux3 - uy3 + 4.5*(u2-uxuy2) )-fij[8]); //SE(1,-1)

					} else {
						g_status = "UNSTABLE at i="+i+",j="+j+",rho="+rh.toFixed(3)+"<br>"+
									"change kinetic viscosity or fan vx and press reset";
					}
				} else if (g_kind[i][j]==1) { // wall: bounce-back boundary
					fij[0] = 0.0;
					m = fij[1]; fij[1] = fij[3]; fij[3] = m; // 1:E(1,0) 3:W(-1,0)
					m = fij[2]; fij[2] = fij[4]; fij[4] = m; // 2:N(0,1) 4:S(0,-1)
					m = fij[5]; fij[5] = fij[7]; fij[7] = m; // 5:NE(1,1) 7:SW(-1,-1)
					m = fij[6]; fij[6] = fij[8]; fij[8] = m; // 6:NW(-1,1) 8:SE(1,-1)
				} else if (g_kind[i][j]==2) { // velocity boundary
					setEquiLattice(fij, 1.0, g_vxBoundary, g_vyBoundary, i, j);
				}
			}
		}
	}

	function setEquiLattice(veq, rh, vx, vy, i, j) {
		g_rho[i][j] = rh;
		g_ux[i][j] = vx;
		g_uy[i][j] = vy;
		setEquilibriumV9(veq, rh, vx, vy);
	}

	function setEquilibriumV9(veq, rh, vx, vy) {
		var w0rh,w1rh,w2rh,ux3,uy3,ux2,uy2,uxuy2,u2,c0;
		// feq[k] = wk*rho*(1+3*(ek.u)+4.5*(ek.u)^2-1.5u^2) (D2Q9 at c=dx/dt=1)
		var w0rh = rh*4.0/9.0;
		var w1rh = rh/9.0;
		var w2rh = rh/36.0;
		var ux3 = 3.0*vx;
		var uy3 = 3.0*vy;
		var ux2 = vx*vx;
		var uy2 = vy*vy;
		var uxuy2 = 2.0*vx*vy;
		var u2 = ux2 + uy2;
		var c0 = 1.0 - 1.5*u2;

		veq[0] = w0rh * (c0                              ); // 0(0,0)
		veq[1] = w1rh * (c0 + ux3       + 4.5*ux2        ); // E(1,0)
		veq[2] = w1rh * (c0       + uy3 + 4.5*uy2        ); // N(0,1)
		veq[3] = w1rh * (c0 - ux3       + 4.5*ux2        ); // W(-1,0)
		veq[4] = w1rh * (c0       - uy3 + 4.5*uy2        ); // S(0,-1)
		veq[5] = w2rh * (c0 + ux3 + uy3 + 4.5*(u2+uxuy2) ); //NE(1,1)
		veq[6] = w2rh * (c0 - ux3 + uy3 + 4.5*(u2-uxuy2) ); //NW(-1,1)
		veq[7] = w2rh * (c0 - ux3 - uy3 + 4.5*(u2+uxuy2) ); //SW(-1,-1)
		veq[8] = w2rh * (c0 + ux3 - uy3 + 4.5*(u2-uxuy2) ); //SE(1,-1)
	}

	//--- utility

	function vorticity(i, j) {
		if (i==0 || i==g_NNx-1 || j==0 || j==g_NNy-1) return 0.0;
		return (g_uy[i+1][j]-g_uy[i-1][j])/(2*g_dx)-(g_ux[i][j+1]-g_ux[i][j-1])/(2*g_dy);
	}
	
	function speed(i,j) {
		var uxij= g_ux[i][j], uyij= g_uy[i][j];
		return Math.sqrt( uxij*uxij+uyij*uyij );
	}
	
	function totalRho() {
		var i,j,nnx=g_NNx,nny=g_NNy, s=0.0;

		for (i=0; innx; i++) {
			for (j=0; j<nny; j++) {
				if (g_kind[i][j]==0) s += g_rho[i][j];
			}
		}
		return s;
	}

	function meanRho() {
		var i,j,nnx=g_NNx,nny=g_NNy, n=0, s=0.0;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				if (g_kind[i][j]==0) {
					n++;
					s += g_rho[i][j];
				}
			}
		}
		return s/n;
	}


	//--------------------  draw  --------------------

	function draw(ctx, drawMode, dispAdd ) {
		var px=20,py=20, sc=g_drawScale;
		var iProbe,jProbe;

		if ( g_imageData==null ) {
			g_imageData = ctx.getImageData(20, 30, 540, 180);
			setImageData();
		}

		drawField(ctx, drawMode,px,py,sc); // drawMode  0:wall 1:density 2:vorticity 3:flow speed

		if (dispAdd==1) { // dispAdd  0:none 1:flow vx,vy 2:powder
			drawFlow(ctx, px,py,sc);
		} else if (dispAdd==2) {
			powder.draw(ctx, px,py,sc); // powder
		}

		ctx.fillStyle = "rgb(0, 0, 0)";
		//ctx.fillText("drawMode="+drawMode+",  dispAdd=="+dispAdd, 10, g_yCanvasSize-2);
		ctx.fillText("time="+g_sysTime+",  nue="+g_userParam.nue, 10, g_yCanvasSize-2);
		ctx.fillText("(rho-1)x"+g_userParam.rhoMag, 300, g_yCanvasSize-2);
		ctx.fillStyle = "rgb(0, 0, 0)";
		ctx.fillText("(rho-1)x"+g_userParam.rhoMag, 300, g_yCanvasSize-2);
		/*
		if (prbON) {
			ctx.font = "11px 'sans-serif'";
			ctx.fillStyle = "rgb(180, 0, 180)";
			ctx.fillRect(g_xProbe+px-1,g_yProbe+py-1,3,3);
			iProbe=Math.floor(g_xProbe/sc);
			jProbe=Math.floor(g_yProbe/sc);
			ctx.fillText("probe("+iProbe+","+jProbe+"), rho="+g_rho[iProbe][jProbe].toFixed(4)+
							", vx="+g_ux[iProbe][jProbe].toFixed(4)+", vy="+g_uy[iProbe][jProbe].toFixed(4)+
							"   (click to move)", 20, 18);
			ctx.font = "16px 'sans-serif'";
		}
		*/
	}

	function setImageData() {
		var i,j,idx,xSize=540,ySize=180, data,r,g,b;

		data = g_imageData.data;
		for (j=0; j<ySize; j++) {
			for (i = 0; i<xSize; i++) {
				idx = (j*xSize+i)*4;
				data[idx] = 0xbb;
				data[++idx] = 0xbb;
				data[++idx] = 0xbb;
				data[++idx] = 0xff;
			}
		}
	}

	function drawField(ctx, FieldMode,px,py,sc) {
		var i,j,nnx=g_NNx,nny=g_NNy,colIndex, deg,aSize=sc;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				if (FieldMode==0) { // wall
					deg = -60;
				} else if (FieldMode==1) { // rho[i][j]
					deg = Math.floor(120*g_userParam.rhoMag*(g_rho[i][j]-1.0));
				} else if (FieldMode==2) { // vorticity(i,j)
					deg = Math.floor(5000*vorticity(i,j));
				} else if (FieldMode==3) { // speed(i,j)
					deg = Math.floor(1200*(Math.sqrt(g_ux[i][j]*g_ux[i][j]+g_uy[i][j]*g_uy[i][j])-0.1));
				}
				if (deg<-150) deg = -150;
				if (deg>150) deg = 150;
				colIndex = ((120-deg)+360)%360;
				// wall
				if (g_kind[i][j]==1) colIndex = 360; // color black

				setSquare(i*aSize,(nny-j)*aSize,aSize,colIndex);
			}
		}
		ctx.putImageData(g_imageData, px, py);
	}

	function setSquare(ix,iy,aSize,colIndex) {
		var pi,pj,idx, xSize=540;

		for (pj=iy; pj<iy+aSize; pj++) {
			for (pi=ix; pi<ix+aSize; pi++) {
				idx = (pj*xSize+pi)*4;
				g_imageData.data[idx] = g_hue[0][colIndex];
				g_imageData.data[idx+1] = g_hue[1][colIndex];
				g_imageData.data[idx+2] = g_hue[2][colIndex];
			}
		}
	}

	function setSquare2Canvas(ctx, ix,iy,aSize,colIndex) {
		ctx.fillStyle = g_hueColor[colIndex];
		ctx.fillRect(ix,iy,aSize,aSize);
	}

	function drawFlow(ctx, px,py,sc) {
		var i,j,nnx=g_NNx,nny=g_NNy,mag=100, vx,vy;

		for (i=2; i<nnx; i+=5) {
			for (j=2; j<nny; j+=5) {
				ctx.strokeStyle = (g_ux[i][j]>0) ? "#4444ff" : "#ff4444";
				ctx.beginPath();
				ctx.lineTo(px+i*sc, py+(nny-j)*sc);
				ctx.lineTo(px+i*sc+g_ux[i][j]*mag, py+(nny-j)*sc-g_uy[i][j]*mag);
				ctx.stroke();
			}
		}
	}


	//--------------------  powder (LB2D)  --------------------

	// external var g_NNx,g_NNy,g_dx,g_dy,g_dt,g_ux[][],g_uy[][],g_kind[][]

	var powder = {};   // namespace of powder module
	powder.n = 300;    // n: number of powder
	powder.x = [];     // x-position of i-th powder
	powder.y = [];     // y-position of i-th powder

	powder.setInitialPosition = function() {
		var i, nn=powder.n, px=powder.x, py=powder.y;

		for (i=0; i<nn; i++) {
			px[i] = (g_NNx-2)*Math.random()+1;
			py[i] = (g_NNy-2)*Math.random()+1;
		}
	};

	powder.move = function() {
		var i,ix,iy,nnx=g_NNx,nny=g_NNy,nn=powder.n, ta=g_dt*(1.0/g_dx), px=powder.x, py=powder.y;

		for (i=0; i<nn; i++) {
			ix = Math.floor(px[i]);
			iy = Math.floor(py[i]);
			px[i] += g_ux[ix][iy]*ta;
			py[i] += g_uy[ix][iy]*ta;
			if (px[i]>=nnx) px[i] -= nnx;
			if (px[i]<0) px[i] += nnx;
			if (py[i]>=nny) py[i] -= nny;
			if (py[i]<0) py[i] += nny;
			if (g_kind[ix][iy]==1) {
				px[i] = (nny-2)*Math.random()+1;
				py[i] = (nny-2)*Math.random()+1;
			} else if (g_kind[ix][iy]==2) {
				if ( Math.random()<0.001 ) {
					px[i] = (nny-2)*Math.random()+1;
					py[i] = (nny-2)*Math.random()+1;
				}
			}
		}
	};

	powder.draw = function(ctx, xp,yp,sc) {
		var i, nn=powder.n, px=powder.x, py=powder.y, yMax=g_NNy*g_dx;

		ctx.fillStyle = "#ff80ff";
		for (i=0; i<nn; i++) {
			ctx.fillRect(xp+px[i]*sc,yp+(yMax-py[i])*sc,2,2);
		}
	};


	//--------------------  public  --------------------

	return {
		init:			setInitialCondition,	// setInitialCondition( theme, objectNum )
		evolve:			timeEvolution,			// timeEvolution( nue, flowVx, nCalc )
		draw:			draw,					// draw( ctx, drawMode, dispAdd, probeON )

		setPowderON:	function( sw ) { g_userParam.powderON = sw; },
		setProbeON:		function( sw ) { g_userParam.probeON = sw; },

		getSysParam:	function() { return [ g_NNx, g_NNy, g_dx, g_dt, powder.n ]; },
		getUserParam:	function() { return [ g_userParam.nue, g_userParam.vxFlow, g_userParam.rhoMag ]; },
		getNow:			function() { return [ g_sysTime, g_status, g_themeStr, g_objectLength ]; },
		getCellKind:	function(i,j) { return g_kind[i][j]; },
		getFlow:		function(i,j) { return [ g_ux[i][j], g_uy[i][j] ]; },
		getDensity:		function(i,j) { return g_rho[i][j]; },	
		getVorticity:	vorticity,				// vorticity(i,j)
		getSpeed:		speed,					// speed(i,j)
		getPowderPos:	function(ipow) { return [ powder.x[ipow], powder.y[ipow] ]; },
  };

})(); //==============  windTunnelLBD2Q9 end  ======================================================================


const tjsm078 = (function(){ //========================  tjsm Module  ==============================================

	// theModule.init( v_theme, v_objectNum )
	// theModule.evolve( v_nCalc )
	// theModule.draw( ctx, drawMode, dispAdd, probeON )
	/*
		// 0:themeStr            1:NNx 2:NNy 3:sc 4:nue 5:vxFan 6:rhoMag
		["wind tunnel(540x180)", 540,  180,  1,   0.02, 0.100, 30.0  ],
		["wind tunnel(270x90)",  270,   90,  2,   0.02, 0.100, 30.0  ],
		["wind tunnel(180x60)",  180,   60,  3,   0.02, 0.100, 30.0  ],
		["wind tunnel(135x45)",  135,   45,  4,   0.02, 0.100, 30.0  ]
	*/
	
	const theModule = windTunnelLBD2Q9;
	let v_theme = 1;		// 1:wind tunnel(270x90)
	let v_objectNum = 0;	// 0:plate, 1:square, 2:circle, 3:triangle, 4:rtiangle2
	let v_nue = 0.02;		// kinetic viscosity
	let v_flowVx = 0.100;	// 0.1*c, c:sound speed
	let v_nCalc = 4;		// number of calc. per frame
	
	let p_nx, p_ny, p_dx, p_dt, p_nPowder; // <-- theModule.getSysParam()
	let p_nue, p_vxFlow, p_rhoMag; // <-- theModule.getUserParam()
	
	let resetFlag = 0;
	let pauseFlag = 0;
	let stepFlag = 0;
	let dispMode =  1;
	let dispModeChanged = false;
	let viewHomeRequested = true;
	let legendFlag = true;
	let count = 0;

	// sizes in the threejs world
	const xBoxSize = 600;
	const zBoxSize = 200;
	const x0 = xBoxSize/2;
	const z0 = zBoxSize/2;
	let hh, yBoxSize, y0;
	
	// threejs world object
	let agrid;
	let vfield;
	let powder;
	let line_box;
	let wall;
	let cnvsprite;
	
	// three.js , OrbitControls.js
	const width = 720;
	const height = 480;
	const r_camera = 850;
	let renderer;
	let scene;
	let camera;
	let controls;
	
	
	// -------------------- lil-gui setup
	
	const uParam = {
		theme: 'wind tunnel (270x90)',
		themeMenu: [ 'wind tunnel (540x180)', 'wind tunnel (270x90)',
					'wind tunnel (180x60)', 'wind tunnel (135x45)' ],
		object:	0,
		objectMenu: { 'plate': 0, 'square': 1, 'circle': 2, 'triangle': 3, 'triangle 2': 4  },
		nue: 0.02,
		flowVx: 0.1,
		nCalc: 4, // RevL = (Reynolds number) / (characteristic length)
		nCalcMenu: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ],
		dispMode: 'pressure + powder',
		dispMenu: [ 'density', 'density + powder', 'z-density + color-vorticity',
					'z-density + color-vorticity + powder', 'z-density + vector-flow(x,y)',
					'canvas2d: flow', 'canvas2d: density + flow', 'canvas2d: vorticity + flow', 'canvas2d speed +flow',
					'canvas2d: powder', 'canvas2d: density + powder', 'canvas2d: vorticity + powder',
					'canvas2d speed +powder' ],
		reset: function() { resetFlag = 1; },
		pause: false,
		viewHome: function() { viewHomeRequested = true; }
	};
	
	const sysMonitor = {
		time: 0.0,
		Re: 100 // kinetic viscosity
	};
	
	const gui = new GUI();
	setupGUI();
	
	function setupGUI() {
		gui.add( uParam, 'theme', uParam.themeMenu ).onChange( 
			str => { v_theme = uParam.themeMenu.indexOf(str); resetFlag = 1; } );
		
		gui.add( uParam, 'object', uParam.objectMenu ).onChange( v => { v_objectNum = v; resetFlag = 1; } );
		
		gui.add( uParam, 'nue', 0.005, 0.2, 0.001 ).name( 'kinetic viscosity' ).onChange( v => { v_nue = v; } );
		
		gui.add( uParam, 'flowVx', 0.0, 0.15, 0.001 ).name( 'vx / sound speed' ).onChange( v => { v_flowVx = v; } );
		
		gui.add( uParam, 'nCalc', uParam.nCalcMenu ).name( 'nCalc / frame' ).onChange( v => { v_nCalc = v; } );
		
		gui.add( uParam, 'dispMode', uParam.dispMenu ).name( 'disp. mode' ).onChange( 
			str => { dispMode = uParam.dispMenu.indexOf(str); dispModeChanged = true; } );
		
		gui.add( uParam, 'reset' );
		gui.add( uParam, 'pause' ).onChange( bool => { pauseFlag = ( bool ) ? 1 : 0; } );
		gui.add( uParam, 'viewHome' ).name( 'camera: home view' );
		
		const folder = gui.addFolder( 'monitor' );
		folder.add( sysMonitor, 'time' ).listen();
		folder.add( sysMonitor, 'Re' ).listen();
	}
	
	
	// --------------------  main
	
	function main() {
		// constract renderer
		renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#myCanvas'), });
		renderer.setSize(width, height);
		
		// camera
		camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000);
		camera.position.set(0, -0.4*r_camera, 0.9*r_camera);
		controls = new OrbitControls(camera,renderer.domElement);
		
		constructScene();
		animate();
	}

	function constructScene() {
		
		// init LB2D
		theModule.init( v_theme, v_objectNum );
		[ p_nx, p_ny, p_dx, p_dt, p_nPowder ] = theModule.getSysParam();
		[ p_nue, p_vxFlow, p_rhoMag ] = theModule.getUserParam();
		hh = xBoxSize/p_nx;
		yBoxSize = hh*p_ny;
		y0 = yBoxSize/2;

		// scene
		scene = new THREE.Scene();
 
		// light - DirectionalLight
		const directionalLight = new THREE.DirectionalLight(0xffffff,0.5);
		directionalLight.position.set(1, 1, 1);
		scene.add(directionalLight);
		// light - AmbientLight
		const light = new THREE.AmbientLight(0xffffff, 1.0);
		scene.add(light);
		
		
		// grid
		// agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
		agrid = m3js_grid2D( p_nx, p_ny, xBoxSize );
		scene.add( agrid );
		
		// flow vector
		// vfield = m3js_vField2D( p_nx, p_ny, xBoxSize [, colorMode] ); // colorMode  0:direction color, 1:blue|red
		vfield = m3js_vField2D( p_nx, p_ny, xBoxSize, 0 );
		scene.add( vfield );
		
		// powder
		// powder = m3js_powder2D( p_nPowder, p_nx, p_ny, xBoxSize [, powderColor] )
		powder = m3js_powder2D( p_nPowder, p_nx, p_ny, xBoxSize );
		powder.setRFactor( 0.8*(p_nx/180.0) );
		scene.add( powder );
		
		// line box
		{
			const geometry = new THREE.BoxGeometry( xBoxSize, yBoxSize, zBoxSize );
			const edges = new THREE.EdgesGeometry( geometry );
			line_box = new THREE.LineSegments( edges, new THREE.LineBasicMaterial({ color: 0x666644 }) );
			scene.add( line_box );
		}
		
		// wallCube
		{
			wall = new THREE.Group();
			for (let i=0; i<p_nx; i++) {
				for (let j=0; j<p_ny; j++) {
					if (theModule.getCellKind(i,j)==1) {
						const geometry = new THREE.BoxGeometry(hh, hh, zBoxSize);
						const material = new THREE.MeshStandardMaterial({ 
							color: 0xaaaaaa, opacity: 0.5, transparent: true});
						const cube = new THREE.Mesh( geometry, material );
						cube.position.set(hh*i-x0, hh*j-y0, 0);
						wall.add( cube );
					}
				}
			}
			wall.visible = true;
			scene.add( wall );
		}
		
		// canvas sprite
		//cnvsprite = m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight )
		cnvsprite = m3js_canvasSprite( 640, 260, 240 );
		cnvsprite.position.set(0,0,0);
		scene.add( cnvsprite );
		
	}

	// loop animation
	function animate() {
		
		// select theme
		if (resetFlag==1) {
			resetFlag = 0;
			constructScene();
			dispModeChanged = true;
			count = 0;
		}

		//  switch visible objects
		if (dispModeChanged) {
			dispModeChanged = false;
			
			line_box.visible = ( dispMode<=4 ) ? true : false;
			wall.visible =  ( dispMode<=4 ) ? true : false;
			
			powder.visible = false;
			agrid.visible = false;
			vfield.visible = false;
			cnvsprite.visible = false;
		}
		
		// view home
		if ( viewHomeRequested ) {
			camera.position.set(0, -0.6*r_camera, 0.8*r_camera);
			viewHomeRequested = false;
		}
		
		// LB2D update
		if (pauseFlag==0) {
			theModule.evolve( v_nue, v_flowVx, v_nCalc );
		} else if ( pauseFlag==1 && stepFlag==1 ) {
			stepFlag = 0;
			theModule.evolve( v_nue, v_flowVx, 1 );
		}
		
		
		// powder update
		if ( dispMode==1 || dispMode==3 ) {
			const rmag = 40.0*p_rhoMag;
			// powder.update( x_y_zPos_Func )
			powder.update( 
				function(i) { //  x_y_zPos_Func(i) --> [ x, y, zPos ]
					let x, y, zPos;
					[ x, y ] = theModule.getPowderPos(i);
					const ix = Math.round(x)%p_nx;
					const iy = Math.round(y)%p_ny;
					zPos = rmag*(theModule.getDensity(ix,iy)-1.0);
					return [ x, y, zPos ];
				} 
			);

		}
		
		// grid density update
		if ( dispMode==0 || dispMode==1 ) {
			const rmag = 40.0*p_rhoMag;
			// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
			agrid.update( 
				function(i,j) { return [ rmag*(theModule.getDensity(i,j)-1.0),   ] } // hue: default
			);
		}
		
		// grid vorticity update
		if ( dispMode==2 || dispMode==3 ) {
			const rmag = 40.0*p_rhoMag;
			// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
			agrid.update( 
				function(i,j) { 
					const z = rmag*(theModule.getDensity(i,j)-1.0);
					const hue = Math.floor(36120.0 - 5000.0*theModule.getVorticity(i,j)) % 360;
					return [ z, hue ];
				}
			);
		}
		
		// flow vector field update
		if ( dispMode==4 ) {
			const fmag = 100.0;
			const rmag = 40.0*p_rhoMag;
			// vfield.update( vx_vy_z_col_func [,step] ); // vx_vy_z_col_func: (i,j) --> [vx, vy, z, [col] ]
			vfield.update(
				function(i,j) { // vx_vy_z_col_func: (i,j) --> [vx, vy, z, [col] ]
					let vx, vy;
					[ vx, vy ] = theModule.getFlow(i,j);
					const z = rmag*(theModule.getDensity(i,j)-1.0);
					return [ fmag*vx, fmag*vy, z,  ];  // col: default
				},
				2 // step
			);
		}
		
		// update sprite
		if ( dispMode>=5 ) {
			// cnvsprite.update( drawFunc )
			cnvsprite.update( 
				function( sprite ) { // drawFunc(sprite)
					const ctx = sprite.ctx;
					const canvasWidth = sprite.canvas.width;
					const canvasHeight = sprite.canvas.height;
					
					// clear canvas
					ctx.fillStyle = "#bbbbbb";
					ctx.fillRect( 0,0, canvasWidth, canvasHeight);
					
					const drawMode = (dispMode - 5) % 4;
					const dispAdd = ( (dispMode - 5)<4 ) ? 1 : 2;
					const prbON = false;
					theModule.draw(ctx, drawMode, dispAdd );
				}
			);
		}
		
		
		// output to innerHTML
		if (count % 10 == 0) {
			const L = 10*p_dx; // pillar: L
			const xMax = p_nx*p_dx, yMax = p_ny*p_dx;
			[ p_nue, p_vxFlow, p_rhoMag ] = theModule.getUserParam();
			let time, status, themeStr, typicalLength;
			[ time, status, themeStr, typicalLength ] = theModule.getNow();
			let Re = Math.round(typicalLength*p_vxFlow/p_nue);
			let msg = "time ="+time.toFixed(1)
				+ ", L="+typicalLength
				+ ", Re="+Re+"<br>"
				+ "nue(kinetic viscosity) ="+p_nue
				+ ", vx/c(sound speed)="+p_vxFlow;

			document.getElementById("text_caption").innerHTML = msg;
			
			if ( legendFlag && dispMode<=4 ) {
				let msg1 = "periodic box = "+xMax+" x "+yMax+", system is "
							+ "<span style='color:#ffff00'>"+status+"</span><br>";
				if ( dispMode==2 || dispMode==3 ) {
					msg1 += "vorticity: (<0)blue clockwise, (>0)red counterclockwise rotation <br>"
				}
				if ( status != 'STABLE' ) {
					msg1 += ("<span style='color:#ff4444'>"
							+ "please select lower Re/L and press [reset] button </span><br>");
				}
				document.getElementById('textOnCanvas').innerHTML = msg1;
			} else {
				document.getElementById('textOnCanvas').innerHTML = "";
			}
			
			sysMonitor.time = time.toFixed(1);
			sysMonitor.Re = Re;
		}
		
		
		count += 1;
		controls.update();
		renderer.render(scene, camera);
		requestAnimationFrame(animate);
	}
	
	
	
	// -----------------------  m3js_powder2D function  ---------------------------
	//
	//    ver 0.0.0  2022.06.28 created, last updated on 2022.12.25
	//
	//  external
	//     theModule.getPowderPos(ipow) // (ipow) --> [ x[ipow], y[ipow] ], ( position in realField )
	//        ipow: 0, 1, ..., p_nPowder
	//
	//  powder = m3js_powder2D( p_nPowder, p_nx, p_ny, xBoxSize [, powderColor] );
	//     p_nPowder: number of powders
	//     p_nx: number of x-direction lines, p_ny:number of y-direction lines
	//     xBoxSize: threejs world x-box size
	//     powderColor: color of the powder (default: 0x0xaa44aa )
	//  scene.add( powder );
	// 
	//  powder.update( x_y_zPos_Func )
	//     x_y_zPos_Func: function(ipowder) { ...; return [ xi, yi, zPos ]; }
	//       xi, yi : i-th powder position (xi,yi) in the field
	//       zPos : z-posion in the threejs world box
	//
	//  powder.visible = true | false;
	//
	//  powder.setRFactor( rfac );
	//     rfac: 0.0 ... 1.0  radius of powder = rfac*hh/2
	//
	
	const m3js_powder2D = function( p_nPowder, p_nx, p_ny, xBoxSize, powderColor ) {
		const icosaArray = [];
		const icosas = new THREE.Group();
		const nn = p_nPowder
		const nx = p_nx;
		const ny = p_ny;
		const hh = xBoxSize/nx;
		const x0 = xBoxSize/2;
		const y0 = hh*ny/2;
		const pColor = ( powderColor==undefined ) ? 0xaa44aa : powderColor;
		let rFactor = 1.0;
		
		const geometry = new THREE.IcosahedronGeometry( rFactor*hh/2.0, 1 );
		for ( let i=0; i<nn; i++ ) {
			const material = new THREE.MeshBasicMaterial({ color: pColor });
			const icosa = new THREE.Mesh( geometry, material );
			icosa.visible = false;
			icosaArray[i] = icosa;
			icosas.add( icosaArray[i] );
		}
		icosas.update = icosas_update; // icosas_update( xyPosFunc, zFunc )
		icosas.setRFactor = function( rfac ) { rFactor = rfac; };
		return icosas;
		
		function icosas_update( x_y_zPos_Func ) {
			const mag = rFactor;
			for ( let i=0; i<nn; i++ ) { 
				let x, y, zPos;
				[ x, y, zPos ] = x_y_zPos_Func(i);
				const icosa = icosaArray[i];
				icosa.position.set( x*hh-x0, y*hh-y0, zPos+0.3*hh );
				icosa.scale.set(mag,mag,mag);
				icosa.visible = true;
			}
			icosas.visible = true;
		}
	};
	
	// -----------------------  m3js_powder2D function end
	
	
	// -----------------------  m3js_grid2D function  -----------------------------------------
	//
	//    ver 0.0.0  2022.10.08 created, last updated on 2022.12.20
	//
	//  agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
	//      p_nx: number of x-direction lines, p_ny: number of y-direction lines
	//      xBoxSize: x-box size in the threejs-world
	//		[zBoxSize]: z-box size in the threejs-world
	//      [mode]: if mode=='xLineOnly' -->  grid change to x-lines only
	//            if mode=='yLineOnly' -->  grid change to y-lines only
	//            else or undefined --> grid x-lines and y-lines
	//
	//  scene.add( agrid );
	//
	//  agrid.setPallet( pallet, color );
	//      pallet: pallet number 372 ... 399, (371:inner pallet)
	//      color: col = new THREE.Color( color )
	//
	//  agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
	//      z_hue_func(i,j) { ... return [ z, [hue] ]; }
	//          z: threejs world z-position at grid point (i,j)
	//          hue: 0...359 huedeg, 360(black) ...gray...370(white) 371(inner pallet) 372...399 free
	//              or string shch as 'red', '#ff0000', 'rgb(255,0,0)', 'hsl(0,100%,50%)'
	//
	// agrid.visible = false;
	//
	
	const m3js_grid2D = function( p_nx, p_ny, xBoxSize, zBoxSize, mode ) {
		const hueArray = []; // red:hue[deg][0]  green:hue[deg][1]  blue:hue[deg][2]
		const gridArray = [];
		const nx = p_nx;
		const ny = p_ny
		const hh = xBoxSize/nx;
		const x0 = xBoxSize/2.0;
		const y0 = hh*ny/2.0;
		const z0 = ( zBoxSize==undefined ) ? y0 : zBoxSize/2.0;
		const xLineOnly = ( mode==undefined || mode!='xLineOnly' ) ? false : true;
		const yLineOnly = ( mode==undefined || mode!='yLineOnly' ) ? false : true;
		const agrid = new THREE.Group();
		
		if ( hueArray.length<1 ) init_hueArray();
		
		if ( ! yLineOnly ) {
			for (let j=0; j<ny; j++) {
 				const geometry = new THREE.BufferGeometry();
 				const material = new THREE.LineBasicMaterial( { vertexColors: true } );
				const positions = new Float32Array( nx * 3 );
				const colors = new Float32Array( nx * 3 );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setDrawRange( 0, nx );
    			const line = new THREE.Line(geometry,material);
    			gridArray[j] = line;
    			agrid.add( gridArray[j] );
			}
		}
		if ( ! xLineOnly ) {
			for (let i=0; i<nx; i++) {
				const geometry = new THREE.BufferGeometry();
 				const material = new THREE.LineBasicMaterial( { vertexColors: true } );
				const positions = new Float32Array( ny * 3 );
				const colors = new Float32Array( ny * 3 );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setDrawRange( 0, ny );
    			const line = new THREE.Line(geometry,material);
    			gridArray[ny+i] = line;
    			agrid.add( gridArray[ny+i] );
    		}
    	}
    	
    	agrid.setPallet = setPallet; // setPallet( pallet, color )
		agrid.update = gridUpdate; // gridUpdate( fieldFunc, [hueFunc|huedeg|hueStr] )
		agrid.visible = false;
		
		return agrid;


		// private functions
		
		function gridUpdate( z_hue_Func ) {
			if ( ! yLineOnly ) {
				for (let j=0; j<ny; j++) {
					const line = gridArray[j];
					const positions = line.geometry.attributes.position.array;
					const colors = line.geometry.attributes.color.array;
					for (let i= 0; i<nx; i++) {
						let z, hue, r=0.99, g=0.99, b=0.99;
						[ z, hue ] = z_hue_Func(i,j);
						positions[i*3]   = hh*i - x0;
						positions[i*3+1] = hh*j - y0;
						positions[i*3+2] = z;
						
						if ( hue==undefined ) hue = Math.floor(36180.0 - 180.0*(z/z0)) % 360;
						if ( typeof(hue)=='number' ) {
							const deg = Math.floor(hue);
							r = hueArray[deg][0];
							g = hueArray[deg][1];
							b = hueArray[deg][2];
						} else if ( typeof(hue)=='string' ) {
							const col = new THREE.Color( hue );
							r = col.r; g = col.g; b = col.b;
						}
						colors[i*3]   = r;
						colors[i*3+1] = g;
						colors[i*3+2] = b;
					}
					line.geometry.attributes.position.needsUpdate = true;
					line.geometry.attributes.color.needsUpdate = true;
				}
			}
			if ( ! xLineOnly ) {
				for (let i=0; i<nx; i++) {
					const line = gridArray[ny+i];
					const positions = line.geometry.attributes.position.array;
					const colors = line.geometry.attributes.color.array;
					for (let j= 0; j<ny; j++) {
						let z, hue, r=0.99, g=0.99, b=0.99;
						[ z, hue ] = z_hue_Func(i,j);
						positions[j*3]   = hh*i - x0;
						positions[j*3+1] = hh*j - y0;
						positions[j*3+2] = z;
						
						if ( hue==undefined ) hue = Math.floor(36180.0 - 180.0*(z/z0)) % 360;
						if ( typeof(hue)=='number' ) {
							const deg = Math.floor(hue);
							r = hueArray[deg][0];
							g = hueArray[deg][1];
							b = hueArray[deg][2];
						} else if ( typeof(hue)=='string' ) {
							const col = new THREE.Color( hue );
							r = col.r; g = col.g; b = col.b;
						}
						colors[j*3]   = r;
            			colors[j*3+1] = g;
            			colors[j*3+2] = b;
    				}
					line.geometry.attributes.position.needsUpdate = true;
					line.geometry.attributes.color.needsUpdate = true;
				}
			}
			agrid.visible = true;
		}
		
		function setPallet( pallet, color ) {
			const deg = Math.floor(pallet);
			const col = new THREE.Color( color );
			hueArray[deg][0] = col.r;
			hueArray[deg][1] = col.g;
			hueArray[deg][2] = col.b;
		}
		
		function init_hueArray() {
			// deg= 0...359 hue color, 360: black ... gray ...  370:white,
			// 371: inner use, 372...399 as pallete
			for (let deg=0; deg<360; deg++) {
				hueArray[deg] = [];
				const col = new THREE.Color( 'hsl('+deg+',100%,50%)');
				hueArray[deg][0] = col.r;
				hueArray[deg][1] = col.g;
				hueArray[deg][2] = col.b;
			}
			for (let deg=360; deg<400; deg++) {
				hueArray[deg] = [];
				const x = (deg<371) ? (deg-360)*0.1 : 0.0;
				hueArray[deg][0] = x;
				hueArray[deg][1] = x;
				hueArray[deg][2] = x;
			}
		}
		
	};
	
	// -----------------------  m3js_grid2D function end
	
	
	// -----------------------  m3js_vField2D function  ---------------------------
	//
	//    ver 0.0.0  2022.02.04 created, last updated on 2022.12.20
	//
	//  vfield = m3js_vField2D( p_nx, p_ny, xBoxSize [, colorMode] ); // colorMode  0:direction color, 1:blue|red
	//     nx: number of x-direction division, ny:number of y-direction division
	//     xBoxSize: x-box size in threejs world
	//  scene.add( vfield );
	//
	//  vfield.update( vx_vy_z_col_func [,step] ); // vx_vy_z_col_func: (i,j) --> [vx, vy, z, [col] ]
	//     vx_vy_z_col_func: function(i,j) { return [vx, vy, z, [col] ]; }
	//     [step]: step of for-loop, 1:default, else 2 or 3 or 4 ... 
	//
	//  vfield.visible = false;
	//
	
	function m3js_vField2D( p_nx, p_ny, xBoxSize, colorMode ) {
		const nx = p_nx;
		const ny = p_ny;
		const hh = xBoxSize/p_nx;
		const x0 = xBoxSize/2.0;
		const y0 = hh*p_ny/2.0;
		const vectorArray = [];
		const lines = new THREE.Group();
		const cMode = ( colorMode==undefined ) ? 1 : colorMode;
		
		for (let i=0; i<nx; i++) {
			vectorArray[i] = [];
			for (let j=0; j<ny; j++) {
				const geometry = new THREE.BufferGeometry();
				const positions = new Float32Array( 2 * 3 ); // MAX_POINTS = 2,  3 vertices per point
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setDrawRange( 0, 2 );
				const material = new THREE.LineBasicMaterial( { color: 0x888888 } );
				const line = new THREE.Line( geometry, material );
				line.visible = false;
				vectorArray[i][j] = line;
    			lines.add( vectorArray[i][j] );
			}
		}
		
		lines.update = linesUpdate;
		
		return lines;
		
		
		function linesUpdate( vx_vy_z_col_func, step ) {
			const inc = ( step == undefined ) ? 1 : step;
			for (let i=0; i<nx; i+=inc) {
				for (let j=1; j<ny; j+=inc) {
					const line = vectorArray[i][j];
					const positions = line.geometry.attributes.position.array;
					const vec = vx_vy_z_col_func(i,j);
					if ( !Array.isArray(vec) ) {
						line.visible = false;
						continue;
					}
					let vx, vy, z, col, h=0;
					[ vx, vy, z, col ] = vec;
					if ( col==undefined ) {
						if ( cMode==0 ) {
							h = Math.floor((Math.atan2(vy,vx))*180.0/Math.PI+180.0);

						} else if ( cMode==1 ) {
							h = (vx>=0.0) ? 240 : 0;
						}
						col = `hsl(${h},100%,50%)`;
					}
					let x = hh*i-x0, y = hh*j-y0;
					positions[0] = x; // point 0
					positions[1] = y;
					positions[2] = z;
					positions[3] = x + vx; // point 1
					positions[4] = y + vy;
					positions[5] = z;
					line.visible = true;
					line.material.color = new THREE.Color( col );
					line.geometry.attributes.position.needsUpdate = true;
				}
			}
			lines.visible = true;
		}
	}
	
	// -----------------------  m3js_vField2D function end
	
	
	// -----------------------  m3js_canvasSprite function  ------------------------------
	//
	//    ver 0.0.0  2022.05.06 created, last updated on 2022.12.19
	//
	// cnvsprite = m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight )
	//     spriteWidth: world width of sprite 3D object
	//     spriteHeight: world height of sprite 3D object
	//     canvasHeight: canvas height in pixel
	// scene.add( cnvsprite );
	//
	// cnvsprite.update( drawFunc )
	//     sprite: sprite object
	//     drawFunc: draw(sprite)
	// 
	// cnvsprite.visible = true | false;
	//
	
	function m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight ) {
		// canvas setup
		const canvasWidth = Math.ceil(spriteWidth*canvasHeight/spriteHeight);
		const canvas = document.createElement("canvas");
		canvas.width  = canvasWidth;
		canvas.height = canvasHeight;
		const ctx = canvas.getContext('2d');
		ctx.font = "16px 'sans-serif'";
		ctx.textBaseline = "bottom";
		ctx.textAlign = "left";
		
		// texture <-- canvas
		const texture = new THREE.Texture(canvas);
		texture.needsUpdate = true;
		
		// sprite <-- texture
		const spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
		const sprite = new THREE.Sprite( spriteMaterial );
		
		sprite.scale.set(spriteWidth, spriteHeight, 1);
		sprite.canvas = canvas;
		sprite.ctx = ctx;
		sprite.texture = texture;
		sprite.visible = false;
		sprite.update =
			function( drawFunc ) {
				drawFunc(sprite);
				sprite.visible = true;
				sprite.texture.needsUpdate = true;
			};
		return sprite;
	}
	
	// -----------------------  m3js_canvasSprite function end
	
	
	//--------------------  public  --------------------
	
	return {
		main:			main,			// main()
		
	}

})(); //==============  tjsm078 module end  ========================================================================


// event
const tjsm = tjsm078;
window.addEventListener('load', tjsm.main );


</script>

<!-- %%%%%%%%%%%%%%%%%%%%  end of javaScript  %%%%%%%%%%%%%%%%%%%% -->

</head>

<body>
<p>[tm078] wind tunnel - Lattice Boltzmann Method (D2Q9 model)</p>
<div style="position: relative; overflow: hidden; width: 720px; height: 480px">
  <canvas id="myCanvas" style="position: absolute; top: 0px; left: 0px"></canvas>
  <div id="textOnCanvas" 
    style="position:absolute; top:5px; left:5px; color:#99aa44; background-color:rgba(0, 0, 0, 0);
           font-size:0.9rem"> ... One moment, please.<br> ... setting up the studio ... </div>
</div>

<hr width="500" align="left" color="#a0a0a0">
<div id="text_caption" ></div>
<hr width="500" align="left" color="#a0a0a0">
<a href="javascript:history.back()">back</a> | <a href="http://mike1336.web.fc2.com/index.html">top</a>
<br>

</body>
</html>

