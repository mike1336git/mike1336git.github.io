<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>tm099_electronsTDKS2D</title>

	<style type="text/css">
		body { color:#000000; background-color:#fff8dd; }
	</style>

	<style type="text/css">
		.lil-gui {
			--width: 300px;
			--name-width: 30%;
		}
	</style>

	<script type="importmap">
		{
			"imports": {
				"three": "../libm/three.module.js",
				"orb": "../libm/OrbitControls.js",
				"lil-gui": "../libm/lil-gui.module.min.js"
			}
		}
	</script>


<!-- %%%%%%%%%%%%%%%%%%%%  javaScript  %%%%%%%%%%%%%%%%%%%% -->

<script type="module">

import * as THREE from 'three';
import { OrbitControls } from 'orb';
import { GUI } from 'lil-gui';


'use strict';

/* =================================================================================================================
//
//  tm099_electronsTDKS2D
//    Copyright(C) 2023 Mitsuru Ikeuchi
//    Released under the MIT license ( https://opensource.org/licenses/MIT ) 
//
//    ver 0.0.0  2023.02.06 created, last updated on 2023.02.07
//
//
//------------------------------------------------------------------------------------------------------------------
//
//  time dependent Kohn-Sham 2D : LDA + spin
//
// - solve time dependent Kohn-Sham equation : approximation
//      N. Watanabe and M. Tsukada: Phys. Rev., E65, 036705 (2002)
// - Vxc: LDA
//      J. P. Perdew and A. Zunger; Phys. Rev., B23, 5048 (1981)
//
//  many electron system --> one electron approximation
//    one electron ,  others -> consider as effective potential Veff
//    Kohn-Sham equation {(-d^2/dr^2)+Veff(r)} |i> = e_i |i>,  Veff(r)=Vext+VH+Vx+Vc
//      Veff: one electron feels effective potential
//      Vext: external Potential
//      Vh  : Hartree potential (electron charge -> electro-static potential)
//      Vx,Vc :electron exchange and correlation potential (LDA:Perdew-Zunger)
//    successive approximation
//      solve Kohn-Sham -> electron state,occupation -> electron charge density -> Veff
//
//   quantum electron dynamics
//   - real-space : sttate psi(i) = ph(i)*si (si = spinUp or spinDown)
//   - time dependent Kohn-Sham equation :
//      N. Watanabe and M. Tsukada: Physical Review E, Vol 65, No 3, 036705 (2002)
//      (arXiv physics/0112015)
//      H ph(ri,t) = i d ph(ri,t)/dt, H = -D2/2 + Veff
//      ph(ri,t+dt) = exp(-idt*H) ph(ri,t)
//      approximation : 
//      ph(ri,t+dt) = exp(idt/2*D/2)exp(-idt*Veff)exp(idt/2*D/2)ph(ri,t)
//      Veff: one electron feels effective potential
//        Veff = Vext + Vh + Vx + Vc
//          Vx + Vc : LDA( J. P. Perdew and A. Zunger; Phys. Rev., B23, 5048 (1981) )
//          Vext: external Potential
//          Vh  : Hartree potential (electron charge -> electro-static potential)
//          Vx,Vc :electron exchange and correlation potential (LDA:Perdew-Zunger)
//  loss process
//      ph(i) steepest descent method: |ph(next)> = |ph(i)> - dump{H-Ei}|ph(i)>
//      spin : as another degree of freedom of state : psi(i) = ph(i)*si
//      <psi(i)|psi(j)> = 0 (si,sj parallel), or = 0 (<ph(i)|ph(j)> = 0)
//      {psi(0),..,psi(N)} Gram-Schmidt orthogonallization
//
//  procedure : evolve time dependent Kohn-Sham equation
//      ( state orthogonallity conserved in this process )
//
//   (1) set initial orbit
//      set external potential Vext
//      set initial orbit ph(i)
//
//   (2) evolve time dt/2
//      t <-- t + dt/2
//
//   (3) evolve kinetic part dt/2 - exp(idt/2*D/2)*
//      krStep(ph(i),0.5*dt);
//
//   (4) set electron density
//      rho <-- sum(|ph(i)|^2,i)
//
//   (5) set effective potential
//      Veff = Vext + Vh + Vx + Vc
//      Vh <-- rho (Poisson eq. ,SOR iteration)
//      Vx,Vc <-- rho (LDA:Perdew-Zunger)
//
//   (6) evolve potential part dt - exp(-idt*Veff)*
//      phaseStep(ph(i), Veff, dt);
//
//   (7) evolve time dt/2
//      t <-- t + dt/2
//
//   (8) evolve kinetic part dt/2 - exp(idt/2*D/2)*
//      krStep(ph(i,t+dt/2),0.5*dt);
//
//   goto (2)
//
//
//------------------------------------------------------------------------------------------------------------------
*/

const electronsTDKS2D = (function(){ //========================  electronsTDKS2D Module  ===========================

	// au: atomic unit hBar=1,e=1,me=1,a0=1
	const gc_auLength = 5.29177211e-11;			// (m) 1(au) = gc_auLength (m)
	const gc_auTime = 2.418884326e-17;			// (s) 1(au) = gc_auTime (s)
	const gc_auEnergy = 4.35974465e-18;			// (J) 1(au) = gc_auEnergy (J)
	const gc_au2eV = 27.211386;					// (eV) 1(au) = 27.211386 (eV)
	const gc_NNxMax = 320;						// maximum number of g_NNx
	const gc_NNyMax = 320;						// maximum number of g_NNy
	const gc_NNMax = 320;						// = Math.max(gc_NNxMax,gc_NNyMax);
	const gc_nOrbitMax = 6;						// maximum number of orbit
	const gc_nStateMax = gc_nOrbitMax*2;		// maximum number of state |orbit>,spin

	var g_iterCount = 0;						// iteration count
	var g_sysTime = 0.0;						// (au) system time
	var g_dx = 1.0/4.0;							// (au) x-division
	var g_dy = 1.0/4.0;							// (au) y-division
	var g_timeStep = 0.5*g_dx*g_dx;				// (au) time step dt
	var g_lz = 12.0;							// (au) imaginary length in the z direction
	var g_NNx = 100;							// number of space x-division
	var g_NNy = 100;							// number of space y-division
	var g_numberOfOrbit = 0;					// number of orbit
	var g_numberOfState = 0;					// number of state |orbit>,spin
	var g_numberOfElectron = 0.0;				// number of electron

	//var qmdSW = 0;							// 0-OFF 1-qmd ON (move nuclear)
	//var lossSW = 0;							// 0-lossOFF 1-lossON 2-loss+trans 3-loss+trans,t-stop
	var g_dampingFactor = 0.01;					// damping factor in setLoss()
	var g_broadening = 0.02;					// (au) level broadening in setOccupation

	var g_xCanvasSize = 400;					// in pixel
	var g_yCanvasSize = 400;					// in pixel
	//var g_canvas = null;						// canvas ptr
	//var g_ctx = null;							// = g_canvas.getContext('2d');

	var g_psis = dimInt2(gc_nStateMax,2);		// state |orbit>,S: g_psis[orbit][spin]
	var g_occ = dim1(gc_nStateMax);				// occupation: g_occ[state] 0.0 ... 1.0
	var g_energy = dim1(gc_nStateMax);			// (au) state energy: g_energy[state]
	var g_psi = dim4(gc_nOrbitMax,gc_NNxMax,gc_NNyMax,2); // g_psi[orbit][ix][iy][0/1] 0:real 1:imaginary
	var g_wrk = dim3(gc_NNxMax,gc_NNyMax,2);	// work orbit in steepestDescent() g_wrk[ix][iy][0/1]
	var g_vv = dim2(gc_NNxMax,gc_NNyMax);		// (au) effective potential g_vv[ix][iy]
	var g_vvext = dim2(gc_NNxMax,gc_NNyMax);	// (au) external potential g_vvext[ix][iy]
	var g_vvh = dim2(gc_NNxMax,gc_NNyMax);		// (au) Hartree potential g_vvh[ix][iy]
	var g_vvx = dim2(gc_NNxMax,gc_NNyMax);		// (au) exchange potential g_vvx[ix][iy]
	var g_vvc = dim2(gc_NNxMax,gc_NNyMax);		// (au) correlation potential g_vvc[ix][iy]
	var g_rho = dim2(gc_NNxMax,gc_NNyMax);		// (au) charge density g_rho[ix][iy]

	var g_bRe = dim1(gc_NNMax);					// work b vector in kxStep(),kyStep()
	var g_bIm = dim1(gc_NNMax);					// work b vector in kxStep(),kyStep()
	var g_uRe = dim1(gc_NNMax);					// work u vector in kxStep(),kyStep()
	var g_uIm = dim1(gc_NNMax);					// work u vector in kxStep(),kyStep()

	// for QMD
	const gc_nucNNN = 8;						// nuc array max
	var g_nucMax = 2;							// maximum number of nucleus
	var g_jelliumRadius = 2.0;					// nuc potential jellium radius
	var g_nucMass = dim1(gc_nucNNN);			// mass of nucleus
	var g_nucCharge = dim1(gc_nucNNN);			// charge of nucleus
	var g_nucxx = dim1(gc_nucNNN);				// (au) nuclear x-position
	var g_nucyy = dim1(gc_nucNNN);				// (au) nuclear y-position
	var g_nucvx = dim1(gc_nucNNN);				// (m/s) nuclear x-velocity
	var g_nucvy = dim1(gc_nucNNN);				// (m/s) nuclear y-velocity
	var g_nucfx = dim1(gc_nucNNN);				// (N) nuclear x-force
	var g_nucfy = dim1(gc_nucNNN);				// (N) nuclear x-force

	function dim1(n) {
		var i, a=[];

		for (i=0; i<n; i++) {
			a[i] = 0.0;
		}
		return a;
	}

	function dimInt2(ni,nj) {
		var i,j, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = 0;
			}
		}
		return a;
	}

	function dim2(ni,nj) {
		var i,j, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = 0.0;
			}
		}
		return a;
	}

	function dim3(ni,nj,nk) {
		var i,j,k, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = [];
				for (k=0; k<nk; k++) {
					a[i][j][k] = 0.0;
				}
			}
		}
		return a;
	}

	function dim4(ni,nj,nk,nm) {
		var i,j,k,m, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = [];
				for (k=0; k<nk; k++) {
					a[i][j][k] = [];
					for (m=0; m<nm; m++) {
						a[i][j][k][m] = 0.0;
					}
				}
			}
		}
		return a;
	}


	//--------------------  set initial condition  --------------------

	function setInitialCondition( theme ) {
		var vIndex = 0;

		g_iterCount = 0;
		g_sysTime = 0.0;
		setInitialState( theme );
		setExternalPotential( vIndex );
	}

	function setInitialState(phIndex) {
		var xMax=g_NNx*g_dx,yMax=g_NNy*g_dy;

		if (phIndex==0) { // 2-electron up,up
			g_numberOfOrbit = 2;
			g_numberOfState = g_numberOfOrbit*2;
			g_numberOfElectron =  2.0;
			//setGaussianWaveAndSpin(iOrbit, xPos, yPos,       width, kx, ky, spin) spin 1:up -1:down
			setGaussianWaveAndSpin(0, xMax*0.25, yMax*0.5 , 1.2, 0.0, 2.0,  1); // 1:up
			setGaussianWaveAndSpin(1, xMax*0.5,  yMax*0.5 , 1.2, 0.0, 0.0,  1); // 1:up
		} else if (phIndex==1) { // 2-electron up,down
			g_numberOfOrbit = 2;
			g_numberOfState = g_numberOfOrbit*2;
			g_numberOfElectron =  2.0;
			setGaussianWaveAndSpin(0, xMax*0.25, yMax*0.5 , 1.2, 0.0, 2.0,  1); // 1:up
			setGaussianWaveAndSpin(1, xMax*0.75, yMax*0.5 , 1.2, 0.0,-2.0, -1); // 1:down
		} else if (phIndex==2) { // 3-electron up,up,down
			g_numberOfOrbit = 3;
			g_numberOfState = g_numberOfOrbit*2;
			g_numberOfElectron =  3.0;
			setGaussianWaveAndSpin(0, xMax*0.25, yMax*0.5 , 1.2, 0.0, 2.0,  1); // 1:up
			setGaussianWaveAndSpin(1, xMax*0.75, yMax*0.5 , 1.2, 0.0,-2.0,  1); // 1:up
			setGaussianWaveAndSpin(2, xMax*0.5 , yMax*0.5 , 1.2, 0.0, 0.0, -1); // 1:down
		} else if (phIndex==3) { // 4-electron up,up,up,up
			g_numberOfOrbit = 4;
			g_numberOfState = g_numberOfOrbit*2;
			g_numberOfElectron =  4.0;
			setGaussianWaveAndSpin(0, xMax*0.25, yMax*0.5 , 1.2, 0.0, 2.0,  1); // 1:up
			setGaussianWaveAndSpin(1, xMax*0.75, yMax*0.5 , 1.2, 0.0,-2.0,  1); // 1:up
			setGaussianWaveAndSpin(2, xMax*0.5 , yMax*0.5 , 1.2, 0.0, 0.0,  1); // 1:up
			setGaussianWaveAndSpin(3, xMax*0.5 , yMax*0.75, 1.2, 1.0, 0.0,  1); // 1:up
		}
	}

	function setExternalPotential(vIndex) {

		if ( vIndex==0 ) {
			var xPos = 0.5*g_NNx*g_dx;
			var yPos = 0.5*g_NNy*g_dy;
			var vvextAtXMax = 8.0; // (au)
			setHarmonicPotential(xPos, yPos, vvextAtXMax)
		}
	}

	function clearRho() {
		var i,j,nnx=g_NNx,nny=g_NNy;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				g_rho[i][j] = 0.0;
			}
		}
	}

	//--- wave library

	function setElectronStates(iOrbit, spin) {
		var iState;

		// set electron state orbit -> g_psis[state][0], spin -> g_psis[state][1], and g_occ[]
		iState = iOrbit*2;
		g_psis[iState][0] = iOrbit; g_psis[iState][1] = 1;
		g_psis[iState+1][0] = iOrbit; g_psis[iState+1][1] = -1;
		if (spin==1) { // 1-up spin
			g_occ[iState] = 1.0;
			g_occ[iState+1] = 0.0;
		} else if (spin==-1) { // -1-down spin
			g_occ[iState] = 0.0;
			g_occ[iState+1] = 1.0;
		} else if (spin==2) { // 2-up and down spin
			g_occ[iState] = 1.0;
			g_occ[iState+1] = 1.0;
		}
	}

	function setGaussianWaveAndSpin(iOrbit, xPos, yPos, width, kx, ky, spin) {
		setGaussianWave(g_psi[iOrbit], xPos, yPos, width, kx, ky);
		setElectronStates(iOrbit, spin);
	}

	function setGaussianWave(ph, xPos, yPos, width, kx, ky) { // ph[][][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var x,y,phAb,phPh;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				x = i*g_dx;
				y = j*g_dy;
				phAb = Math.exp(-((x-xPos)*(x-xPos)+(y-yPos)*(y-yPos))/(4.0*width*width) );
				phPh = kx*x+ky*y;
				ph[i][j][0] = phAb*Math.cos(phPh);
				ph[i][j][1] = phAb*Math.sin(phPh);
			}
		}
		for (i=0; i<nnx; i++) {
			ph[i][0][0] = 0.0;
			ph[i][0][1] = 0.0;
			ph[i][nny-1][0] = 0.0;
			ph[i][nny-1][1] = 0.0;
		}
		for (j=0; j<nny-1; j++) {
			ph[0][j][0] = 0.0;
			ph[0][j][1] = 0.0;
			ph[nnx-1][j][0] = 0.0;
			ph[nnx-1][j][1] = 0.0;
		}
		normalize(ph);
	}

	function setH1sWaveAndSpin(iOrbit, xPos, yPos, width, kx, ky, spin) {
		setH1sWave(g_psi[iOrbit], xPos, yPos, width, kx, ky);
		setElectronStates(iOrbit, spin);
	}

	function setH1sWave(ph, xPos, yPos, width, kx, ky) { //ph[][][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var x,y,r,phAb,phPh;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				x = i*g_dx;
				y = j*g_dy;
				r = Math.sqrt((x-xPos)*(x-xPos)+(y-yPos)*(y-yPos) );
				phAb = Math.exp( -r/width );
				phPh = kx*x+ky*y;
				ph[i][j][0] = phAb*Math.cos(phPh);
				ph[i][j][1] = phAb*Math.sin(phPh);
			}
		}
		normalize(ph);
	}

	//--- potential library

	function clearPotential() {
		var i,j,nnx=g_NNx,nny=g_NNy;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				g_vv[i][j] = 0.0;
				g_vvext[i][j] = 0.0;
				g_vvh[i][j] = 0.0;
				g_vvx[i][j] = 0.0;
				g_vvc[i][j] = 0.0;
			}
		}
	}

	function setHarmonicPotential(xPos, yPos, potAtXMax) {
		var i,j,nnx=g_NNx,nny=g_NNy;
		var x,y,k0;

		k0 = potAtXMax/(nnx*g_dx*nnx*g_dx/4.0);
		for (i=0; i<nnx; i++) {
			x = i*g_dx;
			for (j=0; j<nny; j++) {
				y = j*g_dy;
				g_vvext[i][j] = k0*((x-xPos)*(x-xPos)+(y-yPos)*(y-yPos));
			}
		}
	}

	function setJelliumPotential(xPos, yPos, radius, charge) {
		var i,j,nnx=g_NNx,nny=g_NNy;
		var x,y,r;

		for (i=0; i<nnx; i++) {
			x = i*g_dx;
			for (j=0; j<nny; j++) {
				y = j*g_dy;
				r = Math.sqrt((x-xPos)*(x-xPos)+(y-yPos)*(y-yPos));
				if (r>=radius) {
					g_vvext[i][j] = -charge/r;
				} else {
					g_vvext[i][j] = -(charge/radius)*(1.5-0.5*r*r/(radius*radius));
				}
			}
		}
	}


	//--------------------  time evolution  --------------------

	function timeEvolution( nTimes, lossSW, qmdSW ) {
		// lossSW 0-lossOFF 1-lossON 2-loss+trans 3-loss+trans,t-stop
		var i,iState,iOrbit,nState=g_numberOfState;

		g_iterCount += 1;
		if (lossSW<3) {
			for (i=0; i<nTimes; i++) {
				evolveTimeStep(qmdSW,g_timeStep);
			}
		}

		for (iState=0; iState<nState; iState++) {
			iOrbit = g_psis[iState][0];
			g_energy[iState] = kineticEnergy(g_psi[iOrbit]) + potentialEnergy(g_psi[iOrbit],g_vv);
		}
		sortState(nState);

		if (lossSW==1 || lossSW==2 || lossSW==3) { // SD loss process
			setLoss(g_dampingFactor);
			GramSchmidt(nState);
			sortState(nState);
			if (lossSW==2 || lossSW==3) { // transition
				setOcc(nState,g_numberOfElectron);
			}
		}
	}

	//--- evolve timeStep

	function evolveTimeStep(qmdSW,dt) {
		var iOrbit,norb=g_numberOfOrbit;

		// (2) evolve time dt/2
		g_sysTime += 0.5*dt;

		// (3) evolve kinetic part dt/2 : exp(idt/2*D/2)*
		for (iOrbit=0; iOrbit<norb; iOrbit++) {
			kxStep(g_psi[iOrbit],0.5*dt);
			kyStep(g_psi[iOrbit],0.5*dt);
		}

		// (4) set electron density
		setElectronDensity(g_numberOfState);

		// (5) set effective potential
		setEffectivePotential();

		// (6) evolve potential part dt - exp(-idt*Veff)*
		for (iOrbit=0; iOrbit<norb; iOrbit++) {
			phaseStep(g_psi[iOrbit],g_vv,dt);
		}

		// (7) evolve time dt/2
		g_sysTime += 0.5*dt;

		// (8) evolve kinetic part dt/2 : exp(idt/2*D/2)*
		for (iOrbit=0; iOrbit<norb; iOrbit++) {
			kxStep(g_psi[iOrbit],0.5*dt);
			kyStep(g_psi[iOrbit],0.5*dt);
		}

		if (qmdSW==1) moveNuc(dt);
	}


	//--- kx,ky step

	function kxStep(ph, deltat) { // ph[][][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var a,aaAb,auAb, aaRe,aaIm, bbRe,bbIm, bRe=g_bRe,bIm=g_bIm,uRe=g_uRe,uIm=g_uIm;

		a = 4.0*g_dx*g_dx/deltat;
		bbRe = 2.0;
		bbIm = a;
		aaRe = -2.0;
		aaIm = a;
		aaAb = aaRe*aaRe+aaIm*aaIm;
		for (j=1; j<nny-1; j++) {
			for (i=1; i<nnx-1; i++) {
				bRe[i] = bbRe*ph[i][j][0]-bbIm*ph[i][j][1] - ph[i+1][j][0] - ph[i-1][j][0];
				bIm[i] = bbRe*ph[i][j][1]+bbIm*ph[i][j][0] - ph[i+1][j][1] - ph[i-1][j][1];
			}
			uRe[1] = aaRe/aaAb;
			uIm[1] = -aaIm/aaAb;
			ph[1][j][0] = bRe[1]*uRe[1] - bIm[1]*uIm[1];
			ph[1][j][1] = bIm[1]*uRe[1] + bRe[1]*uIm[1];

			for (i=2; i<nnx-1; i++) {
				auAb = (aaRe-uRe[i-1])*(aaRe-uRe[i-1])+(aaIm-uIm[i-1])*(aaIm-uIm[i-1]);
				uRe[i] = (aaRe-uRe[i-1])/auAb;
				uIm[i] = -(aaIm-uIm[i-1])/auAb;
				ph[i][j][0] = (bRe[i]-ph[i-1][j][0])*uRe[i] - (bIm[i]-ph[i-1][j][1])*uIm[i];
				ph[i][j][1] = (bRe[i]-ph[i-1][j][0])*uIm[i] + (bIm[i]-ph[i-1][j][1])*uRe[i];
			}

			for (i=nnx-3; i>=1; i--) {
				ph[i][j][0] -= ph[i+1][j][0]*uRe[i] - ph[i+1][j][1]*uIm[i];
				ph[i][j][1] -= ph[i+1][j][0]*uIm[i] + ph[i+1][j][1]*uRe[i];
			}
		}
	}

	function kyStep(ph, deltat) { // ph[][][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var a,aaAb,auAb, aaRe,aaIm, bbRe,bbIm, bRe=g_bRe,bIm=g_bIm,uRe=g_uRe,uIm=g_uIm;

		a = 4.0*g_dx*g_dx/deltat;
		bbRe = 2.0;
		bbIm = a;
		aaRe = -2.0;
		aaIm = a;
		aaAb = aaRe*aaRe+aaIm*aaIm;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				bRe[j] = bbRe*ph[i][j][0]-bbIm*ph[i][j][1]-ph[i][j+1][0]-ph[i][j-1][0];
				bIm[j] = bbRe*ph[i][j][1]+bbIm*ph[i][j][0]-ph[i][j+1][1]-ph[i][j-1][1];
			}

			uRe[1] = aaRe/aaAb;
			uIm[1] = -aaIm/aaAb;
			ph[i][1][0] = bRe[1]*uRe[1] - bIm[1]*uIm[1];
			ph[i][1][1] = bIm[1]*uRe[1] + bRe[1]*uIm[1];
			for (j=2; j<nny-1; j++) {
				auAb = (aaRe-uRe[j-1])*(aaRe-uRe[j-1])+(aaIm-uIm[j-1])*(aaIm-uIm[j-1]);
				uRe[j] = (aaRe-uRe[j-1])/auAb;
				uIm[j] = -(aaIm-uIm[j-1])/auAb;
				ph[i][j][0] = (bRe[j]-ph[i][j-1][0])*uRe[j] - (bIm[j]-ph[i][j-1][1])*uIm[j];
				ph[i][j][1] = (bRe[j]-ph[i][j-1][0])*uIm[j] + (bIm[j]-ph[i][j-1][1])*uRe[j];
			}

			for (j=nny-3; j>=1; j--) {
				ph[i][j][0] -= ph[i][j+1][0]*uRe[j] - ph[i][j+1][1]*uIm[j];
				ph[i][j][1] -= ph[i][j+1][0]*uIm[j] + ph[i][j+1][1]*uRe[j];
			}
		}
	}

	//--- phase step

	function phaseStep(ph, vv, deltat) { // ph[][][], vv[][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var th,cs,sn,phr,phi;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				th = deltat*vv[i][j];
				cs = Math.cos(th); sn = Math.sin(th);
				phr = ph[i][j][0];
				phi = ph[i][j][1];
				ph[i][j][0] = cs*phr+sn*phi;
				ph[i][j][1] = cs*phi-sn*phr;
			}
		}
	}

	//--- set electron density

	function setElectronDensity(istateMax) {
		var i,j,nnx=g_NNx,nny=g_NNy, iState,iOrbit, psi=g_psi;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				g_rho[i][j] = 0.0;
				for (iState=0; iState<istateMax; iState++) {
					iOrbit = g_psis[iState][0];
					g_rho[i][j] += g_occ[iState]*(psi[iOrbit][i][j][0]*psi[iOrbit][i][j][0]+
									psi[iOrbit][i][j][1]*psi[iOrbit][i][j][1])/g_lz;
				}
			}
		}
	}

	//--- set effective potential

	function setEffectivePotential() {
		var i,j,nnx=g_NNx,nny=g_NNy;

		poisson(50); // set VH
		setVxc();
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				g_vv[i][j] = g_vvext[i][j]+g_vvh[i][j]+g_vvx[i][j]+g_vvc[i][j];
			}
		}
	}

	function poisson(iterMax) {
		var i,j,iter,nnx=g_NNx,nny=g_NNy;
		var h2, w;

		h2 = 2.0*3.1416*g_dx*g_dx;
		w = (1.0/4.0)*1.8; // 1/4 * SOR_omega(1.0<SOR_omega<2.0)
		for (iter=1; iter<iterMax; iter++) {
			for (i=1; i<nnx-1; i++) {
				for (j=1; j<nny-1; j++) {
					g_vvh[i][j] += w*(g_vvh[i+1][j]+g_vvh[i-1][j]+g_vvh[i][j+1]+g_vvh[i][j-1]
										-4.0*g_vvh[i][j]+h2*g_rho[i][j]);
				}
			}
		}
	}

	// LDA :  J. P. Perdew and A. Zunger; Phys. Rev., B23, 5048 (1981)
	function setVxc() {
		var i,j,nnx=g_NNx,nny=g_NNy;
		var c1,rh,rh3,rs,sqrtrs,ec;

		c1 = -0.984745022;
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				rh = g_rho[i][j];
				rh3 = Math.pow(rh,0.33333333);
				g_vvx[i][j] = c1*rh3;

				rs = 0.6204/(rh3+1.0e-20);
				if (rs>=1.0) {
					sqrtrs = Math.sqrt(rs);
					ec = -0.1423/(1.0+1.0529*sqrtrs+0.3334*rs);
					g_vvc[i][j] = ec*(1.0+1.22838*sqrtrs+0.4445*rs)/(1.0+1.0529*sqrtrs+0.3334*rs);
				} else {
					g_vvc[i][j] = -0.05837-0.0084*rs +(0.0311+0.00133*rs)*Math.log(rs);
				}
			}
		}
	}

	function eeCorrelation(rh) {
		var r,ec;

		r = 0.6204/(Math.pow(rh,0.33333333)+1.0e-20);
		if (r>=1.0) {
			ec = -0.1423/(1.0+1.0529*Math.sqrt(r)+0.3334*r);
		} else {
			ec = -0.0480-0.0116*r+(0.0311+0.0020*r)*Math.log(r);
		}
		return ec;
	}


	//--- sort state

	function sortState(maxState){
		var ist,iw, w;

		for (ist=0; ist<maxState-1; ist++) {
			if (g_energy[ist]>g_energy[ist+1]+0.0001) {
				iw = g_psis[ist][0]; g_psis[ist][0]=g_psis[ist+1][0]; g_psis[ist+1][0]=iw;
				iw = g_psis[ist][1]; g_psis[ist][1]=g_psis[ist+1][1]; g_psis[ist+1][1]=iw;
				w = g_occ[ist]; g_occ[ist]=g_occ[ist+1];g_occ[ist+1]=w;
				w = g_energy[ist]; g_energy[ist]=g_energy[ist+1];g_energy[ist+1]=w;
			}
		}
	}

	//--- set loss

	function setLoss(damp) {
		var iob,norb=g_numberOfOrbit;

		for (iob=0; iob<norb; iob++) {
			steepestDescent(g_psi[iob], g_vv, damp);
		}
	}

	function steepestDescent(ph, v, damp) { // ph[][][], v[][]
		var i,j,k,nnx=g_NNx,nny=g_NNy;
		var ee,d2phRe,d2phIm,h2, wrk=g_wrk;

		h2 = 2.0*g_dx*g_dx;
		ee = kineticEnergy(ph)+potentialEnergy(ph,v);

		// wrk = (H - ee)ph
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				wrk[i][j][0] = -(ph[i+1][j][0]+ph[i-1][j][0]+ph[i][j+1][0]+ph[i][j-1][0]-4.0*ph[i][j][0])/h2
								+(v[i][j]-ee)*ph[i][j][0];
				wrk[i][j][1] = -(ph[i+1][j][1]+ph[i-1][j][1]+ph[i][j+1][1]+ph[i][j-1][1]-4.0*ph[i][j][1])/h2
								+(v[i][j]-ee)*ph[i][j][0];
			}
		}

		// ph = ph - damp*(H - E)ph
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				ph[i][j][0] -= damp*wrk[i][j][0];
				ph[i][j][1] -= damp*wrk[i][j][1];
			}
		}

		normalize(ph);
	}

	//--- Gram-Schmidt

	function GramSchmidt(stateMax) {
		var i,j,nnx=g_NNx,nny=g_NNy, iState,jState, iOrbit,jOrbit;
		var pRe,pIm, dxdy=g_dx*g_dy, psis=g_psis,psi=g_psi;

		normalize(psi[0]);

		for (iState=1; iState<stateMax; iState++) {
			iOrbit = psis[iState][0];
			for (jState=0; jState<iState; jState++) {
				jOrbit = psis[jState][0];
				if (psis[jState][1]==psis[iState][1]) { // the same spin
					pRe = 0.0; pIm = 0.0;
					for (i=1; i<nnx-1; i++) {
						for (j=1; j<nny-1; j++) {
							pRe += (psi[jOrbit][i][j][0]*psi[iOrbit][i][j][0] 
								+ psi[jOrbit][i][j][1]*psi[iOrbit][i][j][1])*dxdy;
							pIm += (psi[jOrbit][i][j][0]*psi[iOrbit][i][j][1]
								- psi[jOrbit][i][j][1]*psi[iOrbit][i][j][0])*dxdy;
						}
					}
					for (i=1; i<nnx-1; i++) {
						for (j=1; j<nny-1; j++) {
							psi[iOrbit][i][j][0] -= (pRe*psi[jOrbit][i][j][0]-pIm*psi[jOrbit][i][j][1]);
							psi[iOrbit][i][j][1] -= (pRe*psi[jOrbit][i][j][1]+pIm*psi[jOrbit][i][j][0]);
						}
					}
				}
				normalize(psi[iOrbit]);
			}
		}
	}

	//--- set occupation

	function setOcc(maxState, nElectron) {
		var i;
		var eUpper,eLower,eFermi,ntrial;

		eUpper = g_energy[maxState-1];
		eLower = g_energy[0];
		for (i=0; i<maxState; i++) {
			if (g_energy[i]>eUpper) eUpper = g_energy[i];
			if (g_energy[i]<eLower) eLower = g_energy[i];
		}

		while (eUpper-eLower>1.0e-12) {
			eFermi = (eUpper+eLower)/2.0;
			ntrial = trialOcc(maxState, eFermi);
			if (ntrial<nElectron) {
				eLower = eFermi;
			} else {
				eUpper = eFermi;
			}
		}
		eFermi = (eUpper+eLower)/2.0;

		for (i=0; i<maxState; i++) {
			g_occ[i] = 1.0*FermiDirac(g_energy[i], eFermi);
			if (g_occ[i]<0.0001) g_occ[i] = 0.0;
			if (1.0-g_occ[i]<0.0001) g_occ[i] = 1.0;
		}
	}

	function trialOcc(maxState, eFermi) {
		var i;
		var s = 0.0;

		for (i=0; i<maxState; i++) {
			s += 1.0*FermiDirac(g_energy[i], eFermi);
		}
		return s;
	}

	function FermiDirac(ee, ef) {
		var et = g_broadening;

		return ( 1.0/(Math.exp((ee-ef)/et)+1.0) );
	}

	function levelWidth() { // no use
		var kT;

		kT = g_broadening;
		if (g_iterCount<30) {
			kT=0.1;
		} else {
			kT = 0.1-0.002*(g_iterCount-29);
			if (kT<g_broadening) kT = g_broadening;
		}
		return kT;
	}

	//--- utility

	function norm(ph) { // ph[][][]
		var i,j,nnx=g_NNx,nny=g_NNy, p=0.0;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				p += (ph[i][j][0]*ph[i][j][0]+ph[i][j][1]*ph[i][j][1]);
			}
		}
		return p*g_dx*g_dy;
	}

	function normalize(f) { // f[][][]
		var i,j,nnx=g_NNx,nny=g_NNy, a;
  
		a = Math.sqrt(norm(f));
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				f[i][j][0] = f[i][j][0]/a;
				f[i][j][1] = f[i][j][1]/a;
			}
		}
	}

	function potentialEnergy(ph, v) { // ph[][][], v[][]
		var i,j,nnx=g_NNx,nny=g_NNy, p=0.0;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				p += v[i][j]*(ph[i][j][0]*ph[i][j][0] + ph[i][j][1]*ph[i][j][1]);
			}
		}
		return p*g_dx*g_dy;
	}

	function kineticEnergy(ph) { // ph[][][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var p,d2phRe,d2phIm,h2;

		h2 = 2.0*g_dx*g_dx;
		p = 0.0;
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				d2phRe = -(ph[i+1][j][0]+ph[i-1][j][0]+ph[i][j+1][0]+ph[i][j-1][0]-4.0*ph[i][j][0])/h2;
				d2phIm = -(ph[i+1][j][1]+ph[i-1][j][1]+ph[i][j+1][1]+ph[i][j-1][1]-4.0*ph[i][j][1])/h2;
				p += (ph[i][j][0]*d2phRe+ph[i][j][1]*d2phIm);
			}
		}
		return p*g_dx*g_dy;
	}

	function innerProduct(f, g) { // f[][][], g[][][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var pRe=0.0,pIm=0.0,dxdy=g_dx*g_dy;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				pRe += (f[i][j][0]*g[i][j][0] + f[i][j][1]*g[i][j][1])*dxdy;
				pIm += (f[i][j][0]*g[i][j][1] - f[i][j][1]*g[i][j][0])*dxdy;
			}
		}
		return Math.sqrt(pRe*pRe+pIm*pIm);
	}

	function meanPosX(ph) { // ph[][][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var p=0.0;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				p += i*g_dx*(ph[i][j][0]*ph[i][j][0]+ph[i][j][1]*ph[i][j][1]);
			}
		}
		return ( p*g_dx*g_dy-8.0 );
	}

	function meanPosY(ph) { // ph[][][]
		var i,j,nnx=g_NNx,nny=g_NNy;
		var p=0.0;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				p += j*g_dy*(ph[i][j][0]*ph[i][j][0]+ph[i][j][1]*ph[i][j][1]);
			}
		}
		return ( p*g_dx*g_dy-8.0 );
	}

	function orbPhase(orb,i,j) { // 0...2PI
		return (Math.PI + Math.atan2(g_psi[orb][i][j][1],g_psi[orb][i][j][0])); // atan2(y,x)
	}
	
	function density(orb,i,j) {
		return ( g_psi[orb][i][j][0]*g_psi[orb][i][j][0] + g_psi[orb][i][j][1]*g_psi[orb][i][j][1] );
	}


	//--------------------  move nuclei  --------------------

	function setInitNuc(iNuc, nuclearMass, nuclearCharge, nuclearxx, nuclearyy, nuclearvx, nuclearvy) {
		g_nucMass[iNuc] = nuclearMass*1.67e-27; // kg
		g_nucCharge[iNuc] = nuclearCharge;
		g_nucxx[iNuc] = nuclearxx;
		g_nucyy[iNuc] = nuclearyy;
		g_nucvx[iNuc] = nuclearvx;
		g_nucvy[iNuc] = nuclearvy;
		g_nucfx[iNuc] = 0.0;
		g_nucfy[iNuc] = 0.0;
	}

	function moveNuc(deltat) {
		var i,nnuc=g_nucMax;
		var dtNuc;

		dtNuc = deltat*2.41888e-17; // au to SI unit

		for (i=0; i<nnuc; i++) {
			g_nucvx[i] += 0.5*dtNuc*g_nucfx[i]/g_nucMass[i]; // in SI
			g_nucvy[i] += 0.5*dtNuc*g_nucfy[i]/g_nucMass[i]; // in SI
			g_nucxx[i] += (g_nucvx[i]*dtNuc)/5.29177e-11; // in au
			g_nucyy[i] += (g_nucvy[i]*dtNuc)/5.29177e-11; // in au
		}
		setNucForce();
		for (i=0; i<nnuc; i++) {
			g_nucvx[i] += 0.5*dtNuc*g_nucfx[i]/g_nucMass[i]; // in SI
			g_nucvy[i] += 0.5*dtNuc*g_nucfy[i]/g_nucMass[i]; // in SI
		}

		setNucBoundary();
		setNucleiPotential();
	}

	function setNucBoundary() {
		var i;

		for (i=0; i<nnuc; i++) {
			if (g_nucxx[i]<-2.0) { g_nucxx[i] = -2.0; g_nucvx[i] = -g_nucvx[i]; }
			if (g_nucxx[i]>g_NNx*g_dx+2.0) {g_nucxx[i] = g_NNx*g_dx+2.0; g_nucvx[i] = -g_nucvx[i]; }
			if (g_nucyy[i]<-2.0) { g_nucyy[i] = -2.0; g_nucvy[i] = -g_nucvy[i]; }
			if (g_nucyy[i]>g_NNy*g_dy+2.0) { g_nucyy[i] = g_NNy*g_dy+2.0; g_nucvy[i] = -g_nucvy[i]; }
		}
	}

	function setNucForce() {
		var i,j,nnuc=g_nucMax;
		var xi,xj,yi,yj,r,r2,f;

		for (i=0; i<nnuc; i++) {
			setElectronForceAtNuc(i);
		}
		for (i=0; i<nnuc; i++) {
			for (j=i+1; j<nnuc; j++) {
				xi = g_nucxx[i]; xj = g_nucxx[j];
				yi = g_nucyy[i]; yj = g_nucyy[j];
				r2 = ((xi-xj)*(xi-xj)+(yi-yj)*(yi-yj));
				r = Math.sqrt(r2); if (r<0.5*g_dx) r = 0.5*g_dx;
				f = (4.38975e-18/5.29177e-11)*g_nucCharge[i]*g_nucCharge[j]/(r*r);
				g_nucfx[i] += f*(xi-xj)/r;
				g_nucfy[i] += f*(yi-yj)/r;
				g_nucfx[j] -= f*(xi-xj)/r;
				g_nucfy[j] -= f*(yi-yj)/r;
			}
		}
	}

	function setElectronForceAtNuc(iNuc) {
		var i,j,nnx=g_NNx,nny=g_NNy;
		var f,sx,sy, x,y,r,r2;

		sx = 0.0; sy = 0.0;
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				x = i*g_dx;
				y = j*g_dy;
				r2 = (x-g_nucxx[iNuc])*(x-g_nucxx[iNuc])+(y-g_nucyy[iNuc])*(y-g_nucyy[iNuc]);
				r = Math.sqrt(r2); if (r<g_dx) r = g_dx;
				f = (4.38975e-18/5.29177e-11)*(-g_rho[i][j]*g_lz*g_dx*g_dy)*g_nucCharge[iNuc]/(r*r);
				sx += -f*(x-g_nucxx[iNuc])/r;
				sy += -f*(y-g_nucyy[iNuc])/r;
			}
		}
		g_nucfx[iNuc] = sx;
		g_nucfy[iNuc] = sy;
	}

	//

	function setNucleiPotential() {
		var i,j,iNuc,nnx=g_NNx,nny=g_NNy,nnuc=g_nucMax;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				g_vvext[i][j] = 0.0;
			}
		}

		for (iNuc=0; iNuc<nnuc; iNuc++) {
			addNucPotential(iNuc);
		}
	}

	function addNucPotential(iNuc) {
		var i,j,nnx=g_NNx,nny=g_NNy;
		var a,qq,xPos,yPos, x,y,r;

		a = g_jelliumRadius;
		if (a<0.25) a = 0.25;
		qq = g_nucCharge[iNuc]; // charge
		xPos = g_nucxx[iNuc]; yPos = g_nucyy[iNuc];

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				x = i*g_dx;
				y = j*g_dy;
				r = Math.sqrt((x-xPos)*(x-xPos)+(y-yPos)*(y-yPos));
				if (r>a) {
					g_vvext[i][j] += -qq/r;
				} else {
					g_vvext[i][j] += -(qq/a)*(1.5-0.5*(r*r/(a*a)));
				}
			}
		}
	}


	//--------------------  draw  --------------------

	function draw( ctx, drawMode, dispState ) {
		var xp=20,yp=20,sc=3;

		if (drawMode==0) {
			drawStateTable(ctx); //(xp,yp,sc)
		} else if (drawMode==1) {
			drawPotentialAlongXAxis(ctx, xp,260,sc);
			drawText(ctx, "potential along x-axis", xp, 20, "rgb(80,80,80)")
		} else if (drawMode==2) {
			drawOrbitAlongXAxis(ctx, xp,260,sc);
			drawText(ctx, "orbit along x-axis", xp, 20, "rgb(80,80,80)")
		} else if (drawMode==3) {
			draw2D(ctx, dispState,xp,yp,sc); //(dispState,xp,yp,sc)
		} else if (drawMode==4) {
			draw2D(ctx, -1,xp,yp,sc); //draw rho (-1,xp,yp,sc)
		}

		ctx.fillStyle = "rgb(0,0,0)";
		ctx.fillText("iteration="+g_iterCount, 20, g_yCanvasSize-25);
		ctx.fillText("time="+g_sysTime.toFixed(1)+"(au) ="+(g_sysTime*gc_auTime*1.0e15).toFixed(2)+"(fs)",
						20, g_yCanvasSize-5);
		//document.getElementById("text_caption").innerHTML = 
		//	"in LDA+spin, state energy does not depend on spin state"
	}

	function drawStateTable(ctx) {
		var ist,iob,spin,ib2,norb=g_numberOfOrbit,nState=g_numberOfState,px=20,py=30,ppy;

		ctx.fillStyle = "rgb(0,0,0)";
		ctx.fillText("State Table", px+50, py);
		ctx.fillText("state orbit spin", px, py+20);
		ctx.fillText(" state E", px+150, py+20);
		ctx.fillText("occ", px+250, py+20);
		for (ist=0; ist<nState; ist++) {
			iob = g_psis[ist][0];
			spin = g_psis[ist][1];
			ppy = py+40+ist*20;
			ctx.fillStyle = "hsl("+(240-g_occ[ist]*240)+",100%,50%)";
			ctx.fillText(" | "+ist+" >     "+iob+"     "+((spin==1) ? "up" : "down"), px, ppy);
			ctx.fillText(g_energy[ist].toFixed(4), px+150, ppy);
			ctx.fillText(g_occ[ist].toFixed(4), px+250, ppy);
		}
		ctx.font = "10px 'sans-serif'";
		ctx.fillStyle = "rgb(80,80,80)";
		ppy = py+40+ist*20;
		for (iob=0; iob<norb; iob++) {
			for (ib2=iob; ib2<norb; ib2++) {
				ctx.fillText("<"+iob+"|"+ib2+">="+innerProduct(g_psi[iob], g_psi[ib2]).toFixed(6), 20, ppy);
				ppy += 12;
			}
		}
		ctx.font = "16px 'sans-serif'";
	}

	function draw2D(ctx, ist,xp,yp,sc) {
		var i,j,iob,spin,nnx=g_NNx,nny=g_NNy, p,r,g,b;

		if (ist>=0) {
			iob = g_psis[ist][0];
			spin = g_psis[ist][1];
		}
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				g = Math.floor(g_vv[i][j]*10);
				if (ist>=0) {
					p = g_psi[iob][i][j][0]*1000;
					if (p>0) {
						r = Math.min(Math.floor(p),255);
						b = 0;
					} else {
						r=0;
						b = Math.min(Math.floor(-p),255);
					}
				} else if (ist==-1) {
					p = g_rho[i][j]*50000;
					if (p>0) {
						r = Math.min(Math.floor(p),255);
						b = r;
					}
				}
				ctx.fillStyle = "rgb("+r+","+g+","+b+")";
				ctx.fillRect(i*sc+xp,(nny-j-1)*sc+yp,sc,sc);
			}
		}
		ctx.fillStyle = "rgb(80,80,80)";
		if (ist>=0) {
			ctx.fillText("state="+ist+", orbitNo="+iob+", spin="+((spin==1) ? "up  " : "down")+
							", E ="+g_energy[ist].toFixed(4), xp, 20);
		} else {
			ctx.fillText("electron charge density", xp, 20);
		}
	}

	function drawOrbitAlongXAxis(ctx, xp,yp,sc) {
		var iob,i,nnx=g_NNx,norb=g_numberOfOrbit,pmag=50,emag=10, ke,pe,te,ph,ph0,ph1;
		var snth =Math.sin(15.0*Math.PI/180.0), csth =Math.cos(15.0*Math.PI/180.0);

		drawRho(ctx, xp,yp,sc);

		for (iob=0; iob<norb; iob++) {
			ke = kineticEnergy(g_psi[iob]);
			pe = potentialEnergy(g_psi[iob],g_vvext);
			te = ke+pe;
			ph = g_psi[iob];
			ctx.strokeStyle = "hsl("+iob*60+",100%,50%)";
			ctx.beginPath();
			for (i=0; i<nnx; i++) {
				ph0 = ph[i][g_NNy/2][0]*pmag; ph1 = ph[i][g_NNy/2][1]*pmag;
				ctx.lineTo(xp+(i+snth*ph1)*sc,yp-(ph0+csth*ph1)*sc-te*emag);
			}
			ctx.stroke();
		}
	}

	function drawVeff(ctx, xp,yp,sc,vmag) {

		// base line
		ctx.strokeStyle = "rgb(120,120,120)";
		ctx.beginPath();
		ctx.moveTo(xp, yp);
		ctx.lineTo(xp+(g_NNx-1)*sc, yp);
		ctx.stroke();
		ctx.fillStyle = "rgb(120,120,120)";
		ctx.fillText("0", xp-10, yp+20);
		ctx.fillText(" "+(g_NNx*g_dx)+"(au)", xp+(g_NNx-1)*sc-30, yp+20);
		drawFn(ctx, g_vv,xp,yp,sc,vmag,"rgb(0,200,0)"); // draw Veff
	}

	function drawFn(ctx, ff,xp,yp,sc,vmag,color) {
		var i,nnx=g_NNx;

		ctx.strokeStyle = color;
		ctx.beginPath();
		for (i=0; i<nnx; i++) {
			ctx.lineTo(i*sc+xp,yp-ff[i][g_NNy/2]*vmag);
		}
		ctx.stroke();
	}

	function drawRho(ctx, xp,yp,sc) {
		var i,nnx=g_NNx,jc=g_NNy/2, rmag=5000,vmag=10;

		drawVeff(ctx, xp,yp,sc,vmag);

		ctx.fillStyle = "rgb(120,120,120)";
		for (i=0; i<nnx-1; i++) {
			ctx.beginPath();
			ctx.lineTo(i*sc+xp,yp-g_vv[i][jc]*vmag);
			ctx.lineTo(i*sc+xp,yp-g_vv[i][jc]*vmag-g_rho[i][jc]*rmag);
			ctx.lineTo((i+1)*sc+xp,yp-g_vv[i+1][jc]*vmag-g_rho[i+1][jc]*rmag);
			ctx.lineTo((i+1)*sc+xp,yp-g_vv[i+1][jc]*vmag);
			ctx.closePath();
			ctx.fill();
		}
	}

	function drawPotentialAlongXAxis(ctx, xp,yp,sc) {
		var i, ypp = yp+35,rmag=20000,vmag=10;

		drawRho(ctx, xp,yp,sc); // draw rho + Veff
		drawFn(ctx, g_vvext,xp,yp,sc,vmag,"rgb(0,0,0)"); //Vext
		drawFn(ctx, g_vvh,xp,yp,sc,vmag*10,"rgb(0,0,250)"); //VH
		drawFn(ctx, g_vvx,xp,yp,sc,vmag*10,"rgb(250,250,0)");  //Vx
		drawFn(ctx, g_vvc,xp,yp,sc,vmag*10,"rgb(250,20,250)");  //Vc
		ctx.fillStyle = "rgb(0,0,0)"; ctx.fillText("Vext", 20, ypp);
		ctx.fillStyle = "rgb(0,180,0)"; ctx.fillText("Veff", 100, ypp);
		ctx.fillStyle = "rgb(0,0,250)"; ctx.fillText("VH x10", 20, ypp+20);
		ctx.fillStyle = "rgb(250,250,0)"; ctx.fillText("Vx x10", 100, ypp+20);
		ctx.fillStyle = "rgb(250,20,250)"; ctx.fillText("Vc x10", 180, ypp+20);
	}

	function drawText(ctx, txt, x, y, color) {
		ctx.fillStyle = color;
		ctx.fillText(txt, x, y);
	}



	//--------------------  public  --------------------

	return {
		init:			setInitialCondition,	// setInitialCondition( theme )
		evolve:			timeEvolution,			// timeEvolution( nCalc, lossSW, qmdSW )
		draw:			draw, 					// draw( ctx, drawMode, dispState )
		
		getAUinSI:		function() { return [ gc_auLength, gc_auTime, gc_auEnergy, gc_au2eV ]; },
		getSysParam:	function() { return [ g_NNx, g_NNy, g_dx, g_timeStep, g_numberOfState ]; },
		getNow:			function() { return [ g_iterCount, g_sysTime ]; },
		getOccupation:	function(ist) { return g_occ[ist]; },
		getStEnergy:	function(ist) { return g_energy[ist]; },
		getState:		function(ist) { return [ g_psis[ist][0], g_psis[ist][1] ]; }, // [ orbit, spin ]
		getPsi:			function(orbit,i,j) { return g_psi[orbit][i][j]; }, // [ RePsi, ImPsi ]
		getOrbPhase:	orbPhase,				// orbPhase( orbit, i, j )
		getOrbDensity:	density,				// density( orbit, i, j )
		getDensity:		function(i,j) { return g_rho[i][j]*g_lz; }, // (g_lz : see setElectronDensity(...))
		getVext:		function(i,j) { return g_vvext[i][j]; },
		getVeff:		function(i,j) { return g_vv[i][j]; },
		getVh:			function(i,j) { return g_vvh[i][j]; },
		getVx:			function(i,j) { return g_vvx[i][j]; },
		getVc:			function(i,j) { return g_vvc[i][j]; },
	};

})(); //==============  electronsTDKS2D end  =======================================================================


const tjsm099 = (function(){ //========================  tjsm Module  ==============================================

	// theModule.init( v_theme )
	// theModule.evolve( v_nCalc, v_lossSW, v_qmdSW )
	// theModule.draw( ctx, drawMode, dispState )

	const theModule = electronsTDKS2D;

	let v_theme = 0;	// 0:(up,up) 1:(up,down) 2:(up,up,down) 3:(up,up,up,up)
	let v_nCalc = 2;	// n-times evolve time step 
	let v_lossSW = 0;	// 0-lossOFF 1-lossON 2-loss+trans 3-loss+trans,t-stop
	let v_qmdSW = 0;	// QMD(nuclear motion) 0:off 1:on
	
	let p_auLength, p_auTime, p_auEnergy, p_au2eV // <-- theModule.getAUinSI()
	let p_nx, p_ny, p_dx, p_dt, p_nState = 4; // <-- theModule.getSysParam()
	
	const colour = { vext:"#44aa44", veff:"#44dddd", vH:"#6666dd", vxc:"#aa44aa", rho:"#ffddff" };
	const stateColor = [ "#ff0000", "#ff8800", "#ffff00", "#00ff00", "#00ffff", "#4444ff", "#8844ff", "#ff4488" ];
	
	// program flow control
	let resetFlag = 0;
	let pauseFlag = 0;
	let stepFlag = 0;
	let dispMode = 0; // 0:orbit(x,y), 1:rho(x,y), 2:V(x), 3:canvas2d orbit(x), 4:canvas2d rho(x), 5:canvas2d V(x)
	let dispModeChanged = false;
	let dispState = 0;
	let dispOrbit, dispSpin;
	let legendFlag = true;
	let viewHomeRequested = false;
	let count = 0; // animate() loop count

	// in three.js world
	const xBoxSize = 400; // in three.js world
	const x0 = xBoxSize/2;
	let hh, yBoxSize, zBoxSize, y0, z0;
	
	// 3d object added to scene
	let agrid;
	let cnvsprite;
	let line_box;

	// three.js , OrbitControls.js
	const width = 500;
	const height = 480;
	const r_camera = 1300;
	let renderer;
	let scene;
	let camera;
	let controls;
	
	
	// -------------------- lil-gui setup
	
	const uParam = {
		theme: '2-electrons spin-up,up',
		themeMenu: [ '2-electrons spin-up,up', '2-electrons spin-up,down', '3-electrons spin-up,up,down',
		'4-electrons spin-up,up,up,up' ],
		loss: 0,
		lossMenu: { 'OFF': 0, 'ON': 1, 'ON + transition': 2, 'ON + transition + time stop': 3 }, 
		dispMode: 'rho(x,y) + Vext(x,y)',
		dispMenu: [ 'rho(x,y) + Vext(x,y)', 'phase-orb(x,y) + Vext(x,y)', 'Re[orb(x,y)] + Vext(x,y)',
					'Vext(x,y)', 'Veff(x,y)', '10 X VH(x,y)', '10 X Vxc(x,y)', 'state table',
					'potential along x-axis', 'orbit along x-axis',
					'orbital wave (real part)', 'electron density' ],
		dispState: 0,
		reset: function() { resetFlag = 1; },
		pause: false,
		viewHome: function() { viewHomeRequested = true; }
	};
	
	const gui = new GUI();
	setupGUI();
	
	function setupGUI() {
		gui.add( uParam, 'theme', uParam.themeMenu ).onChange( 
			str => { v_theme = uParam.themeMenu.indexOf(str); resetFlag = 1; } );
		
		gui.add( uParam, 'loss', uParam.lossMenu ).onChange( v => { v_lossSW = v; } ).listen();
		
		gui.add( uParam, 'dispMode', uParam.dispMenu ).onChange( 
			str => { dispMode = uParam.dispMenu.indexOf(str); dispModeChanged = true; } );
		
		gui.add( uParam, 'dispState', [ 0, 1, 2, 3, 4, 5, 6, 7 ] ).onChange( 
			v => { dispState = Math.min(v,p_nState-1); } );
		
		gui.add( uParam, 'reset' );
		gui.add( uParam, 'pause' ).onChange( bool => { pauseFlag = ( bool ) ? 1 : 0; } );
		gui.add( uParam, 'viewHome' ).name( 'camera: home view' );
	}
	

	// --------------------  main
	
	function main() {
		// constract renderer
		renderer = new THREE.WebGLRenderer({
			canvas: document.querySelector('#myCanvas'),
		});
		renderer.setSize(width, height);
		
		// camera
		camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000);
		camera.position.set(0, -0.6*r_camera, 0.8*r_camera);
		controls = new OrbitControls(camera,renderer.domElement);
		
		constructScene();
		animate();
	}
	
	
	function constructScene() {
		
		// init TDKS2D 
		theModule.init( v_theme );
		[ p_auLength, p_auTime, p_auEnergy, p_au2eV ] = theModule.getAUinSI();
		[ p_nx, p_ny, p_dx, p_dt, p_nState ] = theModule.getSysParam();
		v_lossSW = 0;
		uParam.loss = 0;
		
		hh = xBoxSize/p_nx;
		yBoxSize = p_ny*hh;
		zBoxSize = xBoxSize;
		y0 = yBoxSize/2;
		z0 = zBoxSize/2;

		// scene
		scene = new THREE.Scene();
 
		// light - DirectionalLight
		const directionalLight = new THREE.DirectionalLight(0xFFFFFF);
		directionalLight.position.set(1, 1, 1);
		scene.add(directionalLight);
		// light - AmbientLight
		const light = new THREE.AmbientLight(0xFFFFFF, 0.5);
		scene.add(light);
		
		
		// agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
		agrid = m3js_grid2D( p_nx, p_ny, xBoxSize );
		//agrid.setPallet( pallet, color)
		scene.add( agrid );
		agrid.setPallet( 372, '#446644' );
		
		// line_box
		{
			const geometry = new THREE.BoxGeometry( xBoxSize, yBoxSize, zBoxSize );
			const edges = new THREE.EdgesGeometry( geometry );
			line_box = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { 
				color: 0x888844 } ) );
			scene.add( line_box );
		}
		
		// canvas sprite
		// cnvsprite = m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight )
		cnvsprite = m3js_canvasSprite( 680, 680, 400 );
		cnvsprite.position.set(0,0,0);
		cnvsprite.visible = false;
		scene.add( cnvsprite );
		
	}
	
	
	// loop animation
	function animate() {
		
		// select theme
		if (resetFlag==1) {
			resetFlag = 0;
				
			constructScene();
			dispModeChanged = true;
			count = 0;
		}
		
		if ( viewHomeRequested ) {
			camera.position.set(0, -0.6*r_camera, 0.8*r_camera);
			viewHomeRequested = false;
		}
		
		if ( dispModeChanged ) {
			dispModeChanged = false;
			
			line_box.visible = ( dispMode<=6 ) ? true : false;
			agrid.visible = false;
			cnvsprite.visible = false;
		}
		
		// TDKS2D update
		if (pauseFlag==0) {
			theModule.evolve( v_nCalc, v_lossSW, v_qmdSW );
		} else if ( pauseFlag==1 && stepFlag==1 ) {
			stepFlag = 0;
			theModule.evolve( 1, v_lossSW, v_qmdSW );
		}
		[ dispOrbit, dispSpin ] = theModule.getState(dispState);
		
		// disp update
		{
			const rmag = 1000.0;
			const pmag = 300.0;
			const vmag = 10.0;
			const degree = 180.0/Math.PI;
			const occ = theModule.getOccupation(dispState);
			//colour = { vext:"#44aa44", veff:"#44dddd", vH:"#6666dd", vxc:"#aa44aa", rho:"#ffddff" };
			
			if ( dispMode==0 ) { // 0:2D density(x,y)
				// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
				agrid.update(
					function(i,j) { 
						const dens = rmag*theModule.getDensity(i,j);
						const vext = vmag*theModule.getVext(i,j);
						const hue = (dens<0.5*hh) ? 372 : Math.floor(36180.0 - 240.0*(dens/z0)) % 360;
						return  [ dens + vext, hue ];
					}
				);
			
			} else if ( dispMode==1 ) { // 7:2D state-phase(x,y)
				// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
				agrid.update(
					function(i,j) { 
						const orb = rmag*theModule.getOrbDensity(dispOrbit,i,j);
						const vext = vmag*theModule.getVext(i,j);
						let hue = (occ<0.1) ? 365 : theModule.getOrbPhase(dispOrbit,i,j)*degree;
						if (orb<0.5*hh) hue = 372
						return  [ orb + vext, hue ];
					}
				);
			
			} else if ( dispMode==2 ) { // 7:2D Re[state-phi(x,y)
				// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
				agrid.update(
					function(i,j) { 
						const pRe = pmag*theModule.getPsi(dispOrbit,i,j)[0];
						const vext = vmag*theModule.getVext(i,j);
						let hue = (occ<0.1) ? 365 : Math.floor(36180.0 - 240.0*(pRe/z0)) % 360;
						if (Math.abs(pRe)<0.5*hh) hue = 372
						return  [ pRe + vext, hue ];
					}
				);

			} else if ( dispMode==3 ) { // 3:disp Vext
				// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
				agrid.update( function(i,j) { return [ vmag*theModule.getVext(i,j), colour.vext ]; } );
			} else if ( dispMode==4 ) { // 4:Veff
				agrid.update( function(i,j) { return [ vmag*theModule.getVeff(i,j), colour.veff ]; } );
			} else if ( dispMode==5 ) { // 5:vH x 10
				agrid.update( function(i,j) { return [ 10.0*vmag*theModule.getVh(i,j), colour.vH ]; } );
			} else if ( dispMode==6 ) { // 6:Vxc x 10
				agrid.update(
					function(i,j) { return [ 10.0*vmag*(theModule.getVx(i,j)+theModule.getVc(i,j)), colour.vxc ]; }
				);
			}
		}
		
		// sprite update
		if ( dispMode>=7 ) {
			// cnvsprite.update( drawFunc )
			cnvsprite.update(
				function( sprite ) { // drawFunc(sprite)
					const ctx = sprite.ctx;
					const canvasWidth = sprite.canvas.width;
					const canvasHeight = sprite.canvas.height;
					
					// clear canvas
					ctx.fillStyle = "#bbbbbb";
					ctx.fillRect( 0,0, canvasWidth, canvasHeight);
					
					// drawMode  0:state table  1:1D potential 2:1D orbit 3:orbit 4:charge density
					const drawMode = dispMode-7;
					theModule.draw(ctx, drawMode, dispState);
				}
			);
		}
		
		
		// output to innerHTML
		if (count % 20 == 0) {
			const xMax = p_nx*p_dx, yMax = p_ny*p_dx;
			let count, time;
			[ count, time ] = theModule.getNow();
			let stateStr = "";
			if ( dispMode==1 || dispMode==2 || dispMode==10 ) {
				const occ = theModule.getOccupation(dispState);
				const energy = theModule.getStEnergy(dispState);
				stateStr = " | "+dispState+" &gt; "
					+ "occupation="+occ.toString(4)
					+ ", spin :" + ((dispSpin==1) ? "up" : "down");
				
			}
			document.getElementById("text_caption").innerHTML = 
				"box ="+xMax+"x"+yMax+"(au) ~ "+(xMax*p_auLength*1.0e9).toFixed(2)
				+ " x "+(yMax*p_auLength*1.0e9).toFixed(2)+"(nm) <br>"
				+ "time ="+time+"(au) ~"+(time*p_auTime*1.0e15).toFixed(2)+"(fs)<br>"
				+ stateStr;
			
			if ( legendFlag && dispMode<=6 ) {
				let caption = "";
				for (let ist=0; ist<p_nState; ist++ ) {
					const occ = theModule.getOccupation(ist); 
					if ( occ<0.0001 ) continue;
					let orb, spin;
					[ orb, spin ] = theModule.getState(ist);
					const energy = theModule.getStEnergy(ist);
					caption += " "+"<span style='color:"+stateColor[ist]+"'>"+"| "+ist+" &gt;</span>"
							+ " , orbit energy ="+energy.toFixed(6)
							+ "(au), occ ="+occ.toFixed(4)
							+ ", spin :"+ ((spin==1) ? "up" : "down")+"<br>";
				}
				document.getElementById('textOnCanvas').innerHTML = caption;
			} else {
				document.getElementById('textOnCanvas').innerHTML = "";
			}
		}
		
		
		count += 1;
		controls.update();
		renderer.render(scene, camera);
		requestAnimationFrame(animate);
	}
	
	
	
	// -----------------------  m3js_grid2D function  -----------------------------------------
	//
	//    ver 0.0.0  2022.10.08 created, last updated on 2022.12.20
	//
	//  agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
	//      p_nx: number of x-direction lines, p_ny: number of y-direction lines
	//      xBoxSize: x-box size in the threejs-world
	//		[zBoxSize]: z-box size in the threejs-world
	//      [mode]: if mode=='xLineOnly' -->  grid change to x-lines only
	//            if mode=='yLineOnly' -->  grid change to y-lines only
	//            else or undefined --> grid x-lines and y-lines
	//
	//  scene.add( agrid );
	//
	//  agrid.setPallet( pallet, color );
	//      pallet: pallet number 372 ... 399, (371:inner pallet)
	//      color: col = new THREE.Color( color )
	//
	//  agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
	//      z_hue_func(i,j) { ... return [ z, [hue] ]; }
	//          z: threejs world z-position at grid point (i,j)
	//          hue: 0...359 huedeg, 360(black) ...gray...370(white) 371(inner pallet) 372...399 free
	//              or string shch as 'red', '#ff0000', 'rgb(255,0,0)', 'hsl(0,100%,50%)'
	//
	// agrid.visible = false;
	//
	
	const m3js_grid2D = function( p_nx, p_ny, xBoxSize, zBoxSize, mode ) {
		const hueArray = []; // red:hue[deg][0]  green:hue[deg][1]  blue:hue[deg][2]
		const gridArray = [];
		const nx = p_nx;
		const ny = p_ny
		const hh = xBoxSize/nx;
		const x0 = xBoxSize/2.0;
		const y0 = hh*ny/2.0;
		const z0 = ( zBoxSize==undefined ) ? y0 : zBoxSize/2.0;
		const xLineOnly = ( mode==undefined || mode!='xLineOnly' ) ? false : true;
		const yLineOnly = ( mode==undefined || mode!='yLineOnly' ) ? false : true;
		const agrid = new THREE.Group();
		
		if ( hueArray.length<1 ) init_hueArray();
		
		if ( ! yLineOnly ) {
			for (let j=0; j<ny; j++) {
 				const geometry = new THREE.BufferGeometry();
 				const material = new THREE.LineBasicMaterial( { vertexColors: true } );
				const positions = new Float32Array( nx * 3 );
				const colors = new Float32Array( nx * 3 );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setDrawRange( 0, nx );
    			const line = new THREE.Line(geometry,material);
    			gridArray[j] = line;
    			agrid.add( gridArray[j] );
			}
		}
		if ( ! xLineOnly ) {
			for (let i=0; i<nx; i++) {
				const geometry = new THREE.BufferGeometry();
 				const material = new THREE.LineBasicMaterial( { vertexColors: true } );
				const positions = new Float32Array( ny * 3 );
				const colors = new Float32Array( ny * 3 );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setDrawRange( 0, ny );
    			const line = new THREE.Line(geometry,material);
    			gridArray[ny+i] = line;
    			agrid.add( gridArray[ny+i] );
    		}
    	}
    	
    	agrid.setPallet = setPallet; // setPallet( pallet, color )
		agrid.update = gridUpdate; // gridUpdate( fieldFunc, [hueFunc|huedeg|hueStr] )
		agrid.visible = false;
		
		return agrid;


		// private functions
		
		function gridUpdate( z_hue_Func ) {
			if ( ! yLineOnly ) {
				for (let j=0; j<ny; j++) {
					const line = gridArray[j];
					const positions = line.geometry.attributes.position.array;
					const colors = line.geometry.attributes.color.array;
					for (let i= 0; i<nx; i++) {
						let z, hue, r=0.99, g=0.99, b=0.99;
						[ z, hue ] = z_hue_Func(i,j);
						positions[i*3]   = hh*i - x0;
						positions[i*3+1] = hh*j - y0;
						positions[i*3+2] = z;
						
						if ( hue==undefined ) hue = Math.floor(36180.0 - 180.0*(z/z0)) % 360;
						if ( typeof(hue)=='number' ) {
							const deg = Math.floor(hue);
							r = hueArray[deg][0];
							g = hueArray[deg][1];
							b = hueArray[deg][2];
						} else if ( typeof(hue)=='string' ) {
							const col = new THREE.Color( hue );
							r = col.r; g = col.g; b = col.b;
						}
						colors[i*3]   = r;
						colors[i*3+1] = g;
						colors[i*3+2] = b;
					}
					line.geometry.attributes.position.needsUpdate = true;
					line.geometry.attributes.color.needsUpdate = true;
				}
			}
			if ( ! xLineOnly ) {
				for (let i=0; i<nx; i++) {
					const line = gridArray[ny+i];
					const positions = line.geometry.attributes.position.array;
					const colors = line.geometry.attributes.color.array;
					for (let j= 0; j<ny; j++) {
						let z, hue, r=0.99, g=0.99, b=0.99;
						[ z, hue ] = z_hue_Func(i,j);
						positions[j*3]   = hh*i - x0;
						positions[j*3+1] = hh*j - y0;
						positions[j*3+2] = z;
						
						if ( hue==undefined ) hue = Math.floor(36180.0 - 180.0*(z/z0)) % 360;
						if ( typeof(hue)=='number' ) {
							const deg = Math.floor(hue);
							r = hueArray[deg][0];
							g = hueArray[deg][1];
							b = hueArray[deg][2];
						} else if ( typeof(hue)=='string' ) {
							const col = new THREE.Color( hue );
							r = col.r; g = col.g; b = col.b;
						}
						colors[j*3]   = r;
            			colors[j*3+1] = g;
            			colors[j*3+2] = b;
    				}
					line.geometry.attributes.position.needsUpdate = true;
					line.geometry.attributes.color.needsUpdate = true;
				}
			}
			agrid.visible = true;
		}
		
		function setPallet( pallet, color ) {
			const deg = Math.floor(pallet);
			const col = new THREE.Color( color );
			hueArray[deg][0] = col.r;
			hueArray[deg][1] = col.g;
			hueArray[deg][2] = col.b;
		}
		
		function init_hueArray() {
			// deg= 0...359 hue color, 360: black ... gray ...  370:white,
			// 371: inner use, 372...399 as pallete
			for (let deg=0; deg<360; deg++) {
				hueArray[deg] = [];
				const col = new THREE.Color( 'hsl('+deg+',100%,50%)');
				hueArray[deg][0] = col.r;
				hueArray[deg][1] = col.g;
				hueArray[deg][2] = col.b;
			}
			for (let deg=360; deg<400; deg++) {
				hueArray[deg] = [];
				const x = (deg<371) ? (deg-360)*0.1 : 0.0;
				hueArray[deg][0] = x;
				hueArray[deg][1] = x;
				hueArray[deg][2] = x;
			}
		}
		
	};
	
	// -----------------------  m3js_grid2D function end
	
	
	// -----------------------  m3js_canvasSprite function  ------------------------------
	//
	//    ver 0.0.0  2022.05.06 created, last updated on 2022.12.19
	//
	// cnvsprite = m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight )
	//     spriteWidth: world width of sprite 3D object
	//     spriteHeight: world height of sprite 3D object
	//     canvasHeight: canvas height in pixel
	// scene.add( cnvsprite );
	//
	// cnvsprite.update( drawFunc )
	//     sprite: sprite object
	//     drawFunc: draw(sprite)
	// 
	// cnvsprite.visible = true | false;
	//
	
	function m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight ) {
		// canvas setup
		const canvasWidth = Math.ceil(spriteWidth*canvasHeight/spriteHeight);
		const canvas = document.createElement("canvas");
		canvas.width  = canvasWidth;
		canvas.height = canvasHeight;
		const ctx = canvas.getContext('2d');
		ctx.font = "16px 'sans-serif'";
		ctx.textBaseline = "bottom";
		ctx.textAlign = "left";
		
		// texture <-- canvas
		const texture = new THREE.Texture(canvas);
		texture.needsUpdate = true;
		
		// sprite <-- texture
		const spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
		const sprite = new THREE.Sprite( spriteMaterial );
		
		sprite.scale.set(spriteWidth, spriteHeight, 1);
		sprite.canvas = canvas;
		sprite.ctx = ctx;
		sprite.texture = texture;
		sprite.visible = false;
		sprite.update =
			function( drawFunc ) {
				drawFunc(sprite);
				sprite.visible = true;
				sprite.texture.needsUpdate = true;
			};
		return sprite;
	}
	
	// -----------------------  m3js_canvasSprite function end
	
	
	//--------------------  public  --------------------
	
	return {
		main:			main,			// main()
		
	}

})(); //==============  tjsm099 module end  ========================================================================


// event
const tjsm = tjsm099;
window.addEventListener('load', tjsm.main );


</script>

<!-- %%%%%%%%%%%%%%%%%%%%  end of javaScript  %%%%%%%%%%%%%%%%%%%% -->

</head>

<body>
<p>[tm099] electrons - time dependent Kohn-Sham (TDKS2D)</p>
<div style="position: relative; overflow: hidden; width: 500px; height: 480px">
  <canvas id="myCanvas" style="position: absolute; top: 0px; left: 0px"></canvas>
  <div id="textOnCanvas" 
    style="position:absolute; top:5px; left:5px; color:#888888; background-color:rgba(0, 0, 0, 0);
           font-size:0.9rem"> ... One moment, please.<br> ... setting up the studio ... </div>
</div>

<hr width="500" align="left" color="#a0a0a0">
<div id="text_caption" ></div>
<hr width="500" align="left" color="#a0a0a0">
<a href="javascript:history.back()">back</a> | <a href="http://mike1336.web.fc2.com/index.html">top</a>
<br>

</body>
</html>

