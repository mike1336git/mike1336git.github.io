<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>tjs107_RabiOscillationQED3D</title>
  <script src="../lib/three.min.js"></script>
  <script src="../lib/OrbitControls.js"></script>
  <script>

'use strict';

/* =================================================================================================================
//
//  tjs107_RabiOscillationQED3D
//    Copyright(C) 2022-2023 Mitsuru Ikeuchi
//    Released under the MIT license ( https://opensource.org/licenses/MIT ) 
//
//    ver 0.0.0  2022.05.03 created, last updated on 2044.05.09
//    ver 0.0.1  2022.10.03 v1, last updated on 2023.01.15
//
//
//------------------------------------------------------------------------------------------------------------------
//
//  Rabi Oscillation - Quantum Electron Dynamics (QED3D)
//
// -------------  Rabi oscillation
//
//  When a hydrogen-like atom is placed in intense light
//  (which can be thought as the changing electric field E = E0 sin (ωt)),
//  if ω is equal to the energy difference between states,
//  the phenomenon called 'Rabi oscillation'
//  (which repeats resonance absorption and emission) happen. 
//  In the case of H( E(1s)= -0.5 au, E(2px)= -0.125 au),
//  Rabi oscillation should appear when ω of light is 0.375 au,
//  but this hydrogen-like atom appeared at 0.403 au, which is slightly off.
//
// -------------  QED: Quantum Electron Dynamics 3D
//
// - time dependent Schrodinger equation: i(d/dt)psi(r,t) = H psi(r,t)
// - time evolution
//    psi(r,t+dt) = exp(-i dt H) psi(r,t),  (H:Hamiltonian of the system)
//      H = -delta/2 + V(r), delta = d^2/dx^2 + d^2/dy^2 + d^2/dz^2
//    psi(r,t+dt) = exp(-i dt H) psi(r,t) nearly=
//      {exp(-i(dt/2)V} {exp(i dt(delta/2)} {exp(-i(dt/2)V} psi(r,t)
// - algorism: {exp(i dt(delta/2)}
//     QED: Watanabe's algorism (semi-implicit method)
//     Naoki Watanabe, Masaru Tsukada; arXiv:physics/0011068v1
//     (Published from Physical Review E. 62, 2914, (2000).)
//
//     Cayley's form : exp(i dt delta/2) nearly= (1 + i dt delta/4)/(1 - i dt delta/4)
//       psi(r,t+dt) = exp(i dt delta/2) psi(r,dt)
//       (1 - i dt delta/4) psi(r,t+dt) = (1 + i dt delta/4) psi(r,t)
//
//     difference form psi(r,t) --> psi(j,n)
//        psi(j,n+1) - i (dt/dx^2)/4 {psi(j-1,n+1))-2psi(j,n+1)+psi(j+1,n+1)}
//               = psi(j,n) + i (dt/dx^2)/4 {psi(j-1,n))-2psi(j,n)+psi(j+1,n)}
//        x i(4dx^2/dt) by each term
//        psi(j-1,n+1) + A Psi(j,n+1) + psi(j+1,n+1) = -psi(j-1,n) + B Psi(j,n) -psi(j+1,n)
//          where A=(i4dx^2/dt)-2, B=(i4dx^2/dt)+2
//          bnj = -psi(j-1,n) + B Psi(j,n) -psi(j+1,n) is calculated using known psi(j,n)
//          psi(j-1,n+1) + A Psi(j,n+1) + psi(j+1,n+1) = bnj
//
//     solve tri-diagonal equation  A X = B
//         | a1  1  0  0 |  | x1 |    | b1 |
//         |  1 a2  1  0 |  | x2 |  = | b2 |
//         |  0  1 a3  1 |  | x3 |    | b3 |
//         |  0  0  1 a4 |  | x4 |    | b4 |
//
//       u[1] = 1.0/a[1]  // u[] : work vector
//       x[1] = b[1]*u[1]
//
//       for (i=2; i<=N-2; i++) { //forward elimination
//          u[i] = 1/(a[i]-u[i-1])
//          x[i] = (b[i]-x[i-1])*u[i]
//       }
//       for (i=N-3; i<=1; i--) { //backward substitution
//          x[i] -= x[i+1]*u[i]
//       }
//
//
//------------------------------------------------------------------------------------------------------------------
*/

const RabiOscillationQED3D = (function(){ //========================  RabiOscillationQED3D Module  =================

	// au: atomic unit hBar=1,e=1,me=1,a0=1
	const gc_auLength = 5.29177211e-11;				// (m) 1(au) = gc_auLength (m)
	const gc_auTime = 2.418884326e-17;				// (s) 1(au) = gc_auTime (s)
	const gc_auEnergy = 4.35974465e-18;				// (J) 1(au) = gc_auEnergy (J)
	const gc_au2eV = 27.211386;						// (eV) 1(au) = 27.211386 (eV)
	const gc_nxMax = 32;							// NNx max
	const gc_nyMax = 32;							// NNy max
	const gc_nMax = 32;								// max(NNx,NNy,NNz)

	var g_NNx = 32;									// g_NNx*g_dx == x-boxsize
	var g_NNy = 32;									// g_NNy*g_dy == y-boxsize
	var g_NNz = 32;									// g_NNz*g_dz == xz-boxsize
	var g_sysTime = 0.0;							// (au) system time
	var g_dx = 1.0/2.0;								// (au) x-division
	var g_dy = g_dx;								// (au) y-division
	var g_dz = g_dx;								// (au) z-division
	var g_timeStep = 0.5*(g_dx*g_dx);				// (au) time step dt
	var g_dampingFactor = 0.2*g_dx*g_dx;			// steepest descent loss process

	var g_drawDensMag = 1000.0;						// display magnitude of electron density rho
	var g_drawCurrMag = 30000.0;					// display magnitude of prob. current
	var g_drawWallFlag = 0;							// display wall flag

	var g_psi = dim4(gc_nMax,gc_nMax,gc_nMax,2);	// Re(psi) = psi[i][j][k][0], Im(psi) = psi[i][j][k][1]
	var g_vv = dim3(gc_nMax,gc_nMax,gc_nMax);		// external potential vv[i][j][k]
	var g_wrk = dim4(gc_nMax,gc_nMax,gc_nMax,2);	// work wave in steepestDescent()
	var g_bRe = dim1(gc_nMax);						// work b vector in kxStep(),kyStep(),kzStep()
	var g_bIm = dim1(gc_nMax);						// work b vector in kxStep(),kyStep(),kzStep()
	var g_uRe = dim1(gc_nMax);						// work u vector in kxStep(),kyStep(),kzStep()
	var g_uIm = dim1(gc_nMax);						// work u vector in kxStep(),kyStep(),kzStep()

	function dim1(n) {
		var i, a=[];

		for (i=0; i<n; i++) {
			a[i] = 0.0;
		}
		return a;
	}

	function dim3(n) {
		var i,j,k, a=[];

		for (i=0; i<n; i++) {
			a[i] = [];
			for (j=0; j<n; j++) {
				a[i][j] = [];
				for (k=0; k<n; k++) {
					a[i][j][k] = 0.0;
				}
			}
		}
		return a;
	}

	function dim4(n1,n2,n3,n4) {
		var i,j,k,m, a=[];

		for (i=0; i<n1; i++) {
			a[i] = [];
			for (j=0; j<n2; j++) {
				a[i][j] = [];
				for (k=0; k<n3; k++) {
					a[i][j][k] = [];
					for (m=0; m<n4; m++) {
						a[i][j][k][m] = 0.0;
					}
				}
			}
		}
		return a;
	}


	//--------------------  set initial condition  --------------------

	function setInitialCondition( theme ) {
		var x0=8.0,y0=8.0,z0=8.0, px0=0.0,py0=0.0,pz0=0.0;

		g_sysTime = 0.0;
		setGaussianWave(x0,y0,z0, 1.0, px0,py0,pz0); //(xPos,yPos,zPos, wWidth, kx,ky,kz)
		setTimeDependentPotential(x0,y0,z0,g_sysTime); //(x0,y0,z0,t)
	}

	//--- potential

	function setTimeDependentPotential(x0,y0,z0,t) {
		const emField = 0.02, emOmega = 0.403;
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz, x,y,z,r,ef;

		ef = emField*Math.sin(emOmega*t);
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					x = i*g_dx;
					y = j*g_dy;
					z = k*g_dz;
					r = Math.sqrt((x-x0)*(x-x0)+(y-y0)*(y-y0)+(z-z0)*(z-z0));
					if (r<0.2) r = 0.2;
					g_vv[i][j][k] = ef*(x-x0)-1.0/r;
				}
			}
		}
	}

	/*
	function setBoxPotential() { // type 0
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				for (k=0; k<nnz; k++) {
					g_vv[i][j][k] = 0.0;
				}
			}
		}
	}

	function setHarmonicPotential(k0) { // type 1
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var x,y,z,aa,x0,y0,z0;

		aa = k0/(nnx*g_dx*nnx*g_dx/4);
		x0 = nnx*g_dx/2.0; y0 = nny*g_dy/2.0; z0 = nnz*g_dz/2.0;
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				for (k=0; k<nnz; k++) {
					x = i*g_dx; y = j*g_dy; z = k*g_dz;
					g_vv[i][j][k] = aa*((x-x0)*(x-x0)+(y-y0)*(y-y0)+(z-z0)*(z-z0));
				}
			}
		}
	}

	function setWellPotential(r0, v0) { // type 2
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var x,y,z,r, x0,y0,z0;
  
		x0 = Math.floor(nnx*g_dx/2.0+0.1); y0 = Math.floor(nny*g_dy/2.0+0.1); z0 = Math.floor(nnz*g_dz/2.0+0.1);
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				for (k=0; k<nnz; k++) {
					x = i*g_dx; y = j*g_dy; z = k*g_dz;
					r = Math.sqrt((x-x0)*(x-x0)+(y-y0)*(y-y0)+(z-z0)*(z-z0));
					g_vv[i][j][k] = (r<r0) ? 0.0 : v0;
				}
			}
		}
	}

	function setProtonPotential() { // type 3
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var x0,y0,z0,x,y,z,r;

		x0 = Math.floor(nnx*g_dx/2.0+0.1);
		y0 = Math.floor(nny*g_dy/2.0+0.1);
		z0 = Math.floor(nnz*g_dz/2.0+0.1);
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				for (k=0; k<nnz; k++) {
					x = i*g_dx;
					y = j*g_dy;
					z = k*g_dz;
					r = Math.sqrt((x-x0)*(x-x0)+(y-y0)*(y-y0)+(z-z0)*(z-z0));
					if (r<g_dx) r = g_dx/2.0;
					g_vv[i][j][k] = -1.0/r;
				}
			}
		}
	}

	function setWallPotential(xPos, vThick, vHeight) { // type 4
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var x,y,z;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				for (k=0; k<nnz; k++) {
					x = i*g_dx; y = j*g_dy; z = k*g_dz;
					g_vv[i][j][k] = (x>=xPos && x<xPos+vThick) ? vHeight : 0.0;
				}
			}
		}
	}

	function setSlitPotential(wallPos, wallThick, wallHeight, slitWidth, slitSpan) { // type 5
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var x,y,z,ym,w,d;

		ym = nny*g_dy/2.0;
		w = slitWidth/2.0;
		d = slitSpan/2.0;
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				for (k=0; k<nnz; k++) {
					x = i*g_dx; y = j*g_dy; z = k*g_dz;
					if (x>=wallPos && x<wallPos+wallThick) {
						g_vv[i][j][k] = wallHeight;
						if ((y>=ym-d-w && y<=ym-d+w) || (y>=ym+d-w && y<=ym+d+w)) g_vv[i][j][k] = 0.0;
					} else {
						g_vv[i][j][k] = 0.0;
					}
				}
			}
		}
	}
	*/

	//--- wave

	function setGaussianWave(xPos, yPos, zPos, wWidth, kx, ky, kz) { // wave type 0
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var a,x,y,z,phAb,phPh;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					x = i*g_dx;
					y = j*g_dy;
					z = k*g_dz;
					phAb = Math.exp(-((x-xPos)*(x-xPos)+(y-yPos)*(y-yPos)+(z-zPos)*(z-zPos))/(4.0*wWidth*wWidth));
					phPh = kx*x+ky*y+kz*z;
					g_psi[i][j][k][0] = phAb*Math.cos(phPh);
					g_psi[i][j][k][1] = phAb*Math.sin(phPh);
				}
			}
		}
		setWaveBoundary(g_psi);
		normalize(g_psi);
	}

	/*
	function setHOrbitalWave(xPos, yPos, zPos, state) { // wave type 1
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var x,y,z, r, phAb,phPh;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					x = i*g_dx;
					y = j*g_dy;
					z = k*g_dz;
					r = Math.sqrt((x-xPos)*(x-xPos)+(y-yPos)*(y-yPos)+(z-zPos)*(z-zPos));

					phAb = 0.0;
					if (state==0) { // 1s
						phAb = Math.exp( -r );
					} else if (state==1) { // 2s
						phAb = (1.0-0.5*r)*Math.exp( -r/2.0 );
					} else if (state==2) { // 2px
						phAb = (x-xPos)*Math.exp( -r/2.0 );
					} else if (state==3) { // 2py
						phAb = (y-yPos)*Math.exp( -r/2.0 );
					} else if (state==4) { // 2pz
						phAb = (z-zPos)*Math.exp( -r/2.0 );
					} else if (state==5) { // 3s
						phAb = (1.0-(2.0/3.0)*r+(2.0/27.0)*r*r)*Math.exp( -r/3.0 );
					} else if (state==6) { // 3px
						phAb = (x-xPos)*(1.0-(1.0/6.0)*r)*Math.exp( -r/3.0 );
					} else if (state==7) { // 3py
						phAb = (y-yPos)*(1.0-(1.0/6.0)*r)*Math.exp( -r/3.0 );
					} else if (state==8) { // 3pz
						phAb = (z-zPos)*(1.0-(1.0/6.0)*r)*Math.exp( -r/3.0 );
					} else if (state==9) { // 3dex
						phAb = (y-yPos)*(z-zPos)*Math.exp( -r/3.0 );
					} else if (state==10) { // 3dey
						phAb = (z-zPos)*(x-xPos)*Math.exp( -r/3.0 );
					} else if (state==11) { // 3dez
						phAb = (x-xPos)*(y-yPos)*Math.exp( -r/3.0 );
					} else if (state==12) { // 3drz
						phAb = (2.0*(z-zPos)*(z-zPos)-(x-xPos)*(x-xPos)-(y-yPos)*(y-yPos))*Math.exp( -r/3.0 );
					} else if (state==13) { // 3drrz
						phAb = ((x-xPos)*(x-xPos)-(y-yPos)*(y-yPos))*Math.exp( -r/3.0 );
					}

					phPh = 0.0;
					g_psi[i][j][k][0] = phAb*Math.cos(phPh);
					g_psi[i][j][k][1] = phAb*Math.sin(phPh);
				}
			}
		}
		setWaveBoundary(g_psi);
		normalize(g_psi);
	}
	*/

	function setWaveBoundary(ph) { // ph[][][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				ph[i][j][0][0] = 0.0;
				ph[i][j][0][1] = 0.0;
				ph[i][j][nnz-1][0] = 0.0;
				ph[i][j][nnz-1][1] = 0.0;
			}
		}
		for (i=0; i<nnx; i++) {
			for (k=0; k<nnz; k++) {
				ph[i][0][k][0] = 0.0;
				ph[i][0][k][1] = 0.0;
				ph[i][nny-1][k][0] = 0.0;
				ph[i][nny-1][k][1] = 0.0;
			}
		}
		for (j=0; j<nny; j++) {
			for (k=0; k<nnz; k++) {
				ph[0][j][k][0] = 0.0;
				ph[0][j][k][1] = 0.0;
				ph[nnx-1][j][k][0] = 0.0;
				g_psi[nnx-1][j][k][1] = 0.0;
			}
		}
	}


	//--------------------  time evolution  -------------------- 

	function timeEvolution( lossSW ) {
		var x0=8.0,y0=8.0,z0=8.0;

		g_sysTime += g_timeStep;
		setTimeDependentPotential(x0,y0,z0,g_sysTime)
		phaseStep(g_psi,g_vv,0.5*g_timeStep);
		kxStep(g_psi,g_timeStep);
		kyStep(g_psi,g_timeStep);
		kzStep(g_psi,g_timeStep);
		phaseStep(g_psi,g_vv,0.5*g_timeStep);
		if (lossSW==1 || g_sysTime<100*g_timeStep) {
			steepestDescent(g_psi,g_vv,g_dampingFactor);
		}
	}

	function kxStep(ph, deltat) { // ph[][][][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var a,aaAb,auAb;
		var bRe=g_bRe,bIm=g_bIm,uRe=g_uRe,uIm=g_uIm;

		a = 4.0*g_dy*g_dy/deltat;
		aaAb = 4.0+a*a;
		for (k=1; k<nnz-1; k++) {
			for (j=1; j<nny-1; j++) {
				for (i=1; i<nnx-1; i++) {
					bRe[i] = 2.0*ph[i][j][k][0]-a*ph[i][j][k][1] - ph[i+1][j][k][0] - ph[i-1][j][k][0];
					bIm[i] = 2.0*ph[i][j][k][1]+a*ph[i][j][k][0] - ph[i+1][j][k][1] - ph[i-1][j][k][1];
				}

				uRe[1] = -2.0/aaAb;
				uIm[1] = -a/aaAb;
				ph[1][j][k][0] = bRe[1]*uRe[1] - bIm[1]*uIm[1];
				ph[1][j][k][1] = bIm[1]*uRe[1] + bRe[1]*uIm[1];
				//forward elimination
				for (i=2; i<nnx-1; i++) {
					auAb = (-2.0-uRe[i-1])*(-2.0-uRe[i-1])+(a-uIm[i-1])*(a-uIm[i-1]);
					uRe[i] = (-2.0-uRe[i-1])/auAb;
					uIm[i] = -(a-uIm[i-1])/auAb;
					ph[i][j][k][0] = (bRe[i]-ph[i-1][j][k][0])*uRe[i] - (bIm[i]-ph[i-1][j][k][1])*uIm[i];
					ph[i][j][k][1] = (bRe[i]-ph[i-1][j][k][0])*uIm[i] + (bIm[i]-ph[i-1][j][k][1])*uRe[i];
				}
				//backward substitution
				for (i=nnx-3; i>=1; i--) {
					ph[i][j][k][0] -= ph[i+1][j][k][0]*uRe[i] - ph[i+1][j][k][1]*uIm[i];
					ph[i][j][k][1] -= ph[i+1][j][k][0]*uIm[i] + ph[i+1][j][k][1]*uRe[i];
				}
			}
		}
	}

	function kyStep(ph, deltat) { // ph[][][][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var a,aaAb,auAb;
		var bRe=g_bRe,bIm=g_bIm,uRe=g_uRe,uIm=g_uIm;

		a = 4.0*g_dy*g_dy/deltat;
		aaAb = 4.0+a*a;
		for (i=1; i<nnx-1; i++) {
			for (k=1; k<nnz-1; k++) {
				for (j=1; j<nny-1; j++) {
					bRe[j] = 2.0*ph[i][j][k][0]-a*ph[i][j][k][1] - ph[i][j+1][k][0] - ph[i][j-1][k][0];
					bIm[j] = 2.0*ph[i][j][k][1]+a*ph[i][j][k][0] - ph[i][j+1][k][1] - ph[i][j-1][k][1];
				}

				uRe[1] = -2.0/aaAb;
				uIm[1] = -a/aaAb;
				ph[i][1][k][0] = bRe[1]*uRe[1] - bIm[1]*uIm[1];
				ph[i][1][k][1] = bIm[1]*uRe[1] + bRe[1]*uIm[1];
				//forward elimination
				for (j=2; j<nny-1; j++) {
					auAb = (-2.0-uRe[j-1])*(-2.0-uRe[j-1])+(a-uIm[j-1])*(a-uIm[j-1]);
					uRe[j] = (-2.0-uRe[j-1])/auAb;
					uIm[j] = -(a-uIm[j-1])/auAb;
					ph[i][j][k][0] = (bRe[j]-ph[i][j-1][k][0])*uRe[j] - (bIm[j]-ph[i][j-1][k][1])*uIm[j];
					ph[i][j][k][1] = (bRe[j]-ph[i][j-1][k][0])*uIm[j] + (bIm[j]-ph[i][j-1][k][1])*uRe[j];
				}
				//backward substitution
				for (j=nny-3; j>=1; j--) {
					ph[i][j][k][0] -= ph[i][j+1][k][0]*uRe[j] - ph[i][j+1][k][1]*uIm[j];
					ph[i][j][k][1] -= ph[i][j+1][k][0]*uIm[j] + ph[i][j+1][k][1]*uRe[j];
				}
			}
		}
	}

	function kzStep(ph, deltat) { // ph[][][][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var a,aaAb,auAb;
		var bRe=g_bRe,bIm=g_bIm,uRe=g_uRe,uIm=g_uIm;

		a = 4.0*g_dy*g_dy/deltat;
		aaAb = 4.0+a*a;
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					bRe[k] = 2.0*ph[i][j][k][0]-a*ph[i][j][k][1] - ph[i][j][k+1][0] - ph[i][j][k-1][0];
					bIm[k] = 2.0*ph[i][j][k][1]+a*ph[i][j][k][0] - ph[i][j][k+1][1] - ph[i][j][k-1][1];
				}

				uRe[1] = -2.0/aaAb;
				uIm[1] = -a/aaAb;
				ph[i][j][1][0] = bRe[1]*uRe[1] - bIm[1]*uIm[1];
				ph[i][j][1][1] = bIm[1]*uRe[1] + bRe[1]*uIm[1];
				//forward elimination
				for (k=2; k<nnz-1; k++) {
					auAb = (-2.0-uRe[k-1])*(-2.0-uRe[k-1])+(a-uIm[k-1])*(a-uIm[k-1]);
					uRe[k] = (-2.0-uRe[k-1])/auAb;
					uIm[k] = -(a-uIm[k-1])/auAb;
					ph[i][j][k][0] = (bRe[k]-ph[i][j][k-1][0])*uRe[k] - (bIm[k]-ph[i][j][k-1][1])*uIm[k];
					ph[i][j][k][1] = (bRe[k]-ph[i][j][k-1][0])*uIm[k] + (bIm[k]-ph[i][j][k-1][1])*uRe[k];
				}
				//backward substitution
				for (k=nnz-3; k>=1; k--) {
					ph[i][j][k][0] -= ph[i][j][k+1][0]*uRe[k] - ph[i][j][k+1][1]*uIm[k];
					ph[i][j][k][1] -= ph[i][j][k+1][0]*uIm[k] + ph[i][j][k+1][1]*uRe[k];
				}
			}
		}
	}

	function phaseStep(ph, vv, deltat) { // ph[][][][], vv[][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var th, costh,sinth, phRe,phIm;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					th = deltat*vv[i][j][k];
					costh = Math.cos(th); sinth = Math.sin(th);
					phRe = ph[i][j][k][0];
					phIm = ph[i][j][k][1];
					ph[i][j][k][0] = costh*phRe + sinth*phIm;
					ph[i][j][k][1] =-sinth*phRe + costh*phIm;
				}
			}
		}
	}

	// ----- set loss

	function steepestDescent(ph, vv, damp) { // ph[][][][], vv[][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var ee,d2phRe,d2phIm,h2=2.0*g_dx*g_dx;
		var wrk=g_wrk;

		ee = meanKinetic(ph) + meanPotential(ph,vv);
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					wrk[i][j][k][0] = -(ph[i+1][j][k][0]+ph[i-1][j][k][0]+ph[i][j+1][k][0]+ph[i][j-1][k][0]
						+ph[i][j][k+1][0]+ph[i][j][k-1][0]-6.0*ph[i][j][k][0])/h2+(vv[i][j][k]-ee)*ph[i][j][k][0];
					wrk[i][j][k][1] = -(ph[i+1][j][k][1]+ph[i-1][j][k][1]+ph[i][j+1][k][1]+ph[i][j-1][k][1]
						+ph[i][j][k+1][1]+ph[i][j][k-1][1]-6.0*ph[i][j][k][1])/h2+(vv[i][j][k]-ee)*ph[i][j][k][1];
				}
			}
		}
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					ph[i][j][k][0] -= damp*wrk[i][j][k][0];
					ph[i][j][k][1] -= damp*wrk[i][j][k][1];
				}
			}
		}
		normalize(ph);
	}


	//-------------------- utility

	function norm(ph) { // ph[][][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var p=0.0;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					p += (ph[i][j][k][0]*ph[i][j][k][0]+ph[i][j][k][1]*ph[i][j][k][1]);
				}
			}
		}
		return p*g_dx*g_dy*g_dz;
	}

	function normalize(ph) { // ph[][][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var a = 1.0/Math.sqrt(norm(ph));

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					ph[i][j][k][0] *= a;
					ph[i][j][k][1] *= a;
				}
			}
		}
	}

	function meanPotential(ph, vv) { // ph[][][][], vv[][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var p=0.0;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					p += vv[i][j][k]*(ph[i][j][k][0]*ph[i][j][k][0]+ph[i][j][k][1]*ph[i][j][k][1]);
				}
			}
		}
		return p*g_dx*g_dy*g_dz;
	}

	function meanKinetic(ph) { // ph[][][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var p=0.0, h2=g_dx*g_dx, d2phRe, d2phIm;

		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					d2phRe = (ph[i+1][j][k][0]+ph[i-1][j][k][0]+ph[i][j+1][k][0]+ph[i][j-1][k][0]+ph[i][j][k+1][0]
						+ph[i][j][k-1][0]-6.0*ph[i][j][k][0])/h2;
					d2phIm = (ph[i+1][j][k][1]+ph[i-1][j][k][1]+ph[i][j+1][k][1]+ph[i][j-1][k][1]+ph[i][j][k+1][1]
						+ph[i][j][k-1][1]-6.0*ph[i][j][k][1])/h2;
					p += (ph[i][j][k][0]*d2phRe+ph[i][j][k][1]*d2phIm);
				}
			}
		}
		return -0.5*p*g_dx*g_dy*g_dz;
	}

	function probabilityRegion(ph, xBegin, xEnd) { // ph[][][][]
		var i,j,k,nnx=g_NNx,nny=g_NNy,nnz=g_NNz;
		var x,p=0.0;

		for (i=0; i<nnx; i++) {
			x = i*g_dx;
			if (x>=xBegin && x<xEnd) {
				for (j=0; j<nny; j++) {
					for (k=0; k<nnz; k++) {
						p += (ph[i][j][k][0]*ph[i][j][k][0]+ph[i][j][k][1]*ph[i][j][k][1]);
					}
				}
			}
		}
		return p*g_dx*g_dy*g_dz;
	}

	function psiDensity(i,j,k) {
		return (g_psi[i][j][k][0]*g_psi[i][j][k][0]+g_psi[i][j][k][1]*g_psi[i][j][k][1]);
	}

	function psiPhase(i,j,k) { // 0...2PI
		return (Math.PI + Math.atan2(g_psi[i][j][k][1],g_psi[i][j][k][0])); // atan2(y,x)
	}

	function psiXCurrent(i,j,k) {
		var pRe = (g_psi[i+1][j][k][1]-g_psi[i-1][j][k][1])/(2*g_dx);
		var pIm = (-g_psi[i+1][j][k][0]+g_psi[i-1][j][k][0])/(2*g_dx);

		return (g_psi[i][j][k][0]*pRe + g_psi[i][j][k][1]*pIm)*g_dx*g_dy*g_dz;
	}

	function psiYCurrent(i,j,k) {
		var pRe = (g_psi[i][j+1][k][1]-g_psi[i][j-1][k][1])/(2*g_dy);
		var pIm = (-g_psi[i][j+1][k][0]+g_psi[i][j-1][k][0])/(2*g_dy);

		return (g_psi[i][j][k][0]*pRe + g_psi[i][j][k][1]*pIm)*g_dx*g_dy*g_dz;
	}

	function psiZCurrent(i,j,k) {
		var pRe = (g_psi[i][j][k+1][1]-g_psi[i][j][k-1][1])/(2*g_dz);
		var pIm = (-g_psi[i][j][k+1][0]+g_psi[i][j][k-1][0])/(2*g_dz);

		return (g_psi[i][j][k][0]*pRe + g_psi[i][j][k][1]*pIm)*g_dx*g_dy*g_dz;
	}

	function psiRe(i,j,k) {
		return g_psi[i][j][k][0];
	}

	function psiIm(i,j,k) {
		return g_psi[i][j][k][1];
	}

	function Vext(i,j,k) {
		return g_vv[i][j][k];
	}


	//--------------------  cloud  --------------------

	var g_cloud = dim3(g_NNx,g_NNy,g_NNz);
	var g_srnd = [];

	function setCloud(iState) {
		var i,j,k,ip,nnx=g_NNx,nny=g_NNy,nnz=g_NNz, s,stijk,dens,dv=g_dx*g_dy*g_dz;

		set_srnd();
		
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					g_cloud[i][j][k] = 0;
				}
			}
		}
		s = 0; ip = 0
		for (i=1; i<nnx-1; i++) {
			for (j=1; j<nny-1; j++) {
				for (k=1; k<nnz-1; k++) {
					dens = psiDensity(i,j,k);
					s += dens*dv;
					while (s>g_srnd[ip] && ip<1000) {
						g_cloud[i][j][k] += 1;
						ip += 1;
					}
				}
			}
		}
	}

	function set_srnd() {
		var i;

		g_srnd[0] = Math.random();
		for (i=1; i<1001; i++) {
			g_srnd[i] = g_srnd[i-1] + Math.random();
		}
		for (i=0; i<1000; i++) {
			g_srnd[i] = g_srnd[i]/g_srnd[1000];
		}
	}


	//--------------------  public

	return {
		init:				setInitialCondition,	// setInitialCondition( theme)
		evolve:				timeEvolution,			// timeEvolution( lossSW )
		
		setCloud:			setCloud,				// setCloud(iState)
		
		getAUinSI:			function() { return [ gc_auLength, gc_auTime, gc_auEnergy, gc_au2eV ]; },
		getSysParam:		function() { return [ g_NNx,g_NNy,g_NNz, g_dx, g_timeStep ]; },
		getNow:				function() {
								return [ g_sysTime, norm(g_psi), meanKinetic(g_psi), meanPotential(g_psi, g_vv) ]; 
							},
		getPsiDensity:		psiDensity,				// psiDensity(i,j,k)			
		getPsiPhase:		psiPhase,				// psiPhase(i,j,k)
		getPsiCurrent:		function(i,j,k) { return [ psiXCurrent(i,j,k), psiYCurrent(i,j,k), psiZCurrent(i,j,k) ]; },	
		getPsi:				function(i,j,k) { return [ g_psi[i][j][k][0], g_psi[i][j][k][1] ]; },
		getVext:			function(i,j,k) { return g_vv[i][j][k]; },
		getCloud:			function(i,j,k) { return g_cloud[i][j][k]; },
	};

})(); //==============  RabiOscillationQED3D end  ==================================================================


const tjs107 = (function(){ //========================  tjs Module  ================================================

	// theModule.init( v_theme )
	// theModule.evolve( v_lossSW )
	
	const theModule = RabiOscillationQED3D;
	
	let v_theme = 0;  // no use
	let v_lossSW = 0; // 0:no loss, 1:loss
	
	let p_auLength, p_auTime, p_auEnergy, p_au2eV // <-- theModule.getAUinSI()
	let p_nx, p_ny, p_nz, p_dx, p_dt; // <-- theModule.getSysParam()
	let p_densMag=1000.0, p_currMag=30000.0, p_wallSW=0; // <-- theModule.getDrawParam( v_theme );
	
	// program flow control
	let resetFlag = 0;
	let pauseFlag = 0;
	let stepFlag = 0;
	let setPotentialFlag = 0;
	let dispMode = 9; // 9:phase(x,y,z)+V(x,y,0)
	let dispModeChanged = false;
	let legendFlag = true;
	let viewHomeRequested = false;
	let count = 0; // animate() loop count
	let zScanCount = 0;

	// sizes in the threejs world
	const xBoxSize = 400; // in three.js world
	const x0 = xBoxSize/2;
	let hh, yBoxSize, zBoxSize, y0, z0;

	// threejs-object added to scene
	let pgrid;
	let vgrid;
	let grid3D;
	let vfield3D;
	//let cubes = null; // potential wall
	let line_box;

	// three.js global
	const r_camera = 1200.0;
	const width = 500;
	const height = 480;
	let renderer;
	let scene;
	let camera;
	let controls;


	// --------------------  main
	
	function main() {

		// construct renderer
		renderer = new THREE.WebGLRenderer({
			canvas: document.querySelector('#myCanvas'),
		});
		renderer.setSize(width, height);

		// camera
		camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000);
		camera.position.set(0, -0.8*r_camera,0.6*r_camera);
		// lib/OrbitControls.js
		controls = new THREE.OrbitControls(camera,renderer.domElement);
		
		initDom();
		
		constructScene();
		animate();
	}
	
	
	function constructScene() {
		
		// init LDA3D
		theModule.init( v_theme );
		[ p_auLength, p_auTime, p_auEnergy, p_au2eV ] = theModule.getAUinSI();
		[ p_nx, p_ny, p_nz, p_dx, p_dt ] = theModule.getSysParam();
		//[ p_densMag, p_currMag, p_wallSW ] = theModule.getDrawParam( v_theme );
		hh = xBoxSize/p_nx;
		yBoxSize = hh*p_ny;
		zBoxSize = hh*p_nz;
		y0 = yBoxSize/2;
		z0 = zBoxSize/2;
		//cubes = null;

		// scene
		scene = new THREE.Scene();

		// light - DirectionalLight
		const directionalLight = new THREE.DirectionalLight(0xffffff);
		directionalLight.position.set(1, 1, 1);
		scene.add(directionalLight);
		// light - AmbientLight
		const light = new THREE.AmbientLight(0xffffff, 0.5);
		scene.add(light);
		
		
		// 3D density, orbit
		// grid3D = m3js_grid3D( p_nx, p_ny, p_nz, xBoxSize );
		grid3D = m3js_grid3D( p_nx, p_ny, p_nz, xBoxSize );
		scene.add( grid3D );
		
		// add vector field
		// vfield3D = m3js_vField3D( p_nx, p_ny, p_nz, xBoxSize );
		vfield3D = m3js_vField3D( p_nx, p_ny, p_nz, xBoxSize );
		scene.add( vfield3D );
		
		// 2D density, orbit
		// agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
		pgrid = m3js_grid2D( p_nx, p_ny, xBoxSize );
		scene.add( pgrid );
		pgrid.setPallet( 372, 0x446644 );
		
		// 2D potential
		// agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
		vgrid = m3js_grid2D( p_nx, p_ny, xBoxSize );
		scene.add( vgrid );
		
		/*
		// wall
		if ( p_wallSW==1 ) {
			cubes = new THREE.Group();
			const geometry = new THREE.BoxGeometry(0.9*hh, 0.9*hh, 0.9*hh);
			for ( let i=0; i<p_nx; i++ ) {
				for ( let j=0; j<p_ny; j++ ) {
					for ( let k=0; k<p_nz; k++ ) {
						if ( Math.abs(theModule.getVext(i,j,k)) >= 0.8 ) {
							const material = new THREE.MeshStandardMaterial({ 
								color: 0xffffff, opacity: 0.1, transparent: true});
							const cube = new THREE.Mesh( geometry, material );
							cube.position.set(i*hh-x0, j*hh-y0, k*hh-z0);
							cubes.add ( cube );
						}	
					}
				}
			}
			cubes.visible = false;
			scene.add( cubes );
		}
		*/
		
		// line box
		{
			const geometry = new THREE.BoxGeometry( xBoxSize, yBoxSize, zBoxSize );
			const edges = new THREE.EdgesGeometry( geometry );
			line_box = new THREE.LineSegments( edges, new THREE.LineBasicMaterial({ color: 0x888866 }) );
			scene.add( line_box );
		}

	}
	
	
	// loop animation
	function animate() {
		
		// system reset
		if (resetFlag==1) {
			resetFlag = 0;
			
			constructScene();
			v_lossSW = 0;
			document.getElementById("slct_lossSW").selectedIndex = 0;
			dispModeChanged = true;
			count = 0;
		}
		
		if ( viewHomeRequested ) {
			camera.position.set(0, -0.8*r_camera,0.6*r_camera);
			viewHomeRequested = false;
		}
		
		// clear world (object.visible -> false)
		if ( dispModeChanged ) {
			dispModeChanged = false;
			
			line_box.visible = (dispMode<=9) ? true : false;
			//if (cubes!=null) cubes.visible = (dispMode<=7) ? true : false;
			pgrid.visible = false;
			vgrid.visible = false;
			grid3D.visible = false;
			vfield3D.visible = false;
		}
		
		// LDA3D update
		if (pauseFlag==0) {
			theModule.evolve( v_lossSW );
		} else if ( pauseFlag==1 && stepFlag==1 ) {
			stepFlag = 0;
			theModule.evolve( v_lossSW );
			if ( dispMode==3 ) theModule.setCloud();
		}
		
		// disp update
		{
			const rhoMag = 3000.0;
			const phiMag = 600.0;
			const vmag = 50.0;
			const kc = p_nz/2;
			const degree = 180.0/Math.PI;
			let vmode = 0; // 0:V() no draw, 1:green, 2:dark green
			
			if ( dispMode==0 || dispMode==8 ) { // 0:density 
				if ( dispMode==8  ) vmode = 2;
				// grid3D.update( field_func, [hue_func] ); // field_func: (i,j,k) --> field
				grid3D.update( function(i,j,k) { return rhoMag*theModule.getPsiDensity(i,j,k); } );
			
			} else if ( dispMode==1 || dispMode==9 ) { // 1:phase
				if ( dispMode==9  ) vmode = 2;
				// grid3D.update( field_func, [hue_func] ); // field_func: (i,j,k) --> field
				grid3D.update( 
					function(i,j,k) { return rhoMag*theModule.getPsiDensity(i,j,k); },
					function(i,j,k) { return theModule.getPsiPhase(i,j,k)*degree; }
				);
			
			} else if ( dispMode==2 ) { // 2:prob. current
				const cmag = 2.0*p_currMag;
				let cx, cy, cz;
				// grid3D.update( field_func, [hue_func] ); // field_func: (i,j,k) --> field
				grid3D.update( function(i,j,k) { return rhoMag*theModule.getPsiDensity(i,j,k); } );
			
				// prob. current
				// vfield3D.update( vx_vy_vz_hue_func [,step] ); // vx_vy_vz_hue_func: (i,j,k) -->  [ vx, vy, vz, hue ]
				vfield3D.update(
					function(i,j,k) {
						let cx, cy, cz;
						const rho = rhoMag*theModule.getPsiDensity(i,j,k);
						if (rho<0.2*hh) return 0; // -->  visible = false
						[ cx, cy, cz ] = theModule.getPsiCurrent(i,j,k);
						const hue = (cx>0) ? 240 : 0;
						return [ cmag*cx, cmag*cy, cmag*cz, hue ]; 
					}
				);
			
			} else if ( dispMode==3 ) { // 3:cloud 
				if (pauseFlag==0) theModule.setCloud();
				// grid3D.update( field_func, [hue_func] ); // field_func: (i,j,k) --> field
				grid3D.update( function(i,j,k) { return 10.0*theModule.getCloud(i,j,k); } );
		
			} else if ( dispMode==4 ) { // 4:2D potential Vext(x,y,0)
				vmode = 1;
			
			} else if ( dispMode==5 ) { // 5:2D real part of psi(x,y,0)
				// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
				pgrid.update( 
					function(i,j) {
						const pRe = phiMag*theModule.getPsi(i,j,kc)[0];
						const hue = (Math.abs(pRe)<0.5*hh) ? 365 : Math.floor(36180.0 - 180.0*(pRe/z0)) % 360;
						return [ pRe, ]; 
					} 
				);
			
			} else if ( dispMode==6 ) { // 6:2D density(x,y,0)
				// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
				pgrid.update( 
					function(i,j) {
						const dens = rhoMag*theModule.getPsiDensity(i,j,kc);
						const hue = (dens<0.1*hh) ? 365 : Math.floor(36180.0 - 180.0*(dens/z0)) % 360;
						return [ dens, hue ];
					}

				);
			
			} else if ( dispMode==7 ) { // 7:2D phase(x,y,0) + V(x,y,0)
				// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
				pgrid.update(
					function(i,j) {
						const dens = rhoMag*theModule.getPsiDensity(i,j,kc);
						const vext = vmag*theModule.getVext(i,j,kc);
						const hue = (dens<0.1*hh) ? 372 : theModule.getPsiPhase(i,j,kc)*degree;
						return [ dens + vext, hue ];
					}
				);
			}
			
			if ( vmode>0 ) { // 4:2D potential Vext(x,y,0)
				const vcolor = (vmode==1) ? '#00dd00' : '#446644';
				// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
				vgrid.update( function(i,j) { return [ vmag*theModule.getVext(i,j,kc), vcolor ]; } );
			
			}
			
			
		}
		
		
		// output to innerHTML
		if (count % 10 == 0) {
			const xMax = p_nx*p_dx, yMax = p_ny*p_dx, zMax = p_nz*p_dx;
			let time, norm, kineticEnergy, potentialEnergy;
			[ time, norm, kineticEnergy, potentialEnergy ] = theModule.getNow();
			const te = kineticEnergy + potentialEnergy;
			let msg = "box="+xMax+"x"+yMax+"x"+zMax
				+ "(au) ~ "+(xMax*p_auLength*1.0e9).toFixed(2)
				+ "x"+(yMax*p_auLength*1.0e9).toFixed(2)
				+ "x"+(zMax*p_auLength*1.0e9).toFixed(2)
				+ "(nm), time="+time+"(au) <br>"
				+ "total energy: K + U ="+te.toFixed(3)
				+ "(au) ~ "+(te*p_au2eV).toFixed(2)+"(eV)<br>"
				+ "K(au)="+kineticEnergy.toFixed(3)+", U(au)="+potentialEnergy.toFixed(3)
				+ ", norm-1.0="+(norm-1.0).toExponential(3)+"<br>";
			document.getElementById("text_caption").innerHTML = msg;

		}
		
		
		count += 1;
		controls.update();
		renderer.render(scene, camera);
		requestAnimationFrame(animate);
	}
	
	
	
	// -----------------------  m3js_vField3D function  ---------------------------
	//
	//    ver 0.0.0  2022.09.09 created, last updated on 2023.01.10
	//
	//  vfield3D = m3js_vField3D( p_nx, p_ny, p_nz, xBoxSize );
	//     p_nx: number of x-direction division, 
	//     p_ny: number of y-direction division,
	//     p_ny: number of y-direction division,
	//     xBoxSize: x-box size in threejs world
	//  
	//  scene.add( vfield3D );
	//
	//  vfield3D.update( vx_vy_vz_hue_func [,step] ); // vx_vy_vz_hue_func: (i,j,k) -->  [ vx, vy, vz, [hue] ]
	//     vx_vy_vz_hue_func: (i,j,k) --> [ vx, vy, vz, [hue] ]
	//     step: step of for-loop, 1:default, else 2 or 3 or 4 ... 
	//
	//  vfield3D.visible = true | false
	//
	//
	
	const m3js_vField3D = function( p_nx, p_ny, p_nz, xBoxSize ) {
		const vectorArray = [];
		const lines = new THREE.Group();
		const nx = p_nx;
		const ny = p_ny;
		const nz = p_nz;
		const hh = xBoxSize/nx;
		const x0 = xBoxSize/2;
		const y0 = hh*ny/2;
		const z0 = hh*nz/2;
		const threshold = 0.1*hh;
		
		for (let i=0; i<nx; i++) {
			vectorArray[i] = [];
			for (let j=0; j<ny; j++) {
				vectorArray[i][j] = [];
				for (let k=0; k<nz; k++) {
					const geometry = new THREE.BufferGeometry();
					const positions = new Float32Array( 2 * 3 ); // MAX_POINTS = 2,  3 vertices per point
					geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
					geometry.setDrawRange( 0, 2 );
					const material = new THREE.LineBasicMaterial( { color: 0x888888 } );
					const line = new THREE.Line( geometry, material );
					line.visible = false;
					vectorArray[i][j][k] = line;
					lines.add( vectorArray[i][j][k] );
				}
			}
		}
		lines.update = lines_update; // lines_update( vx_vy_vz_hue_func, step )
		
		return lines;
		
		// private functions
		
		function lines_update( vx_vy_vz_hue_func, step ) {
			const inc = ( step == undefined ) ? 1 : step;
			for (let i=0; i<nx; i+=inc) {
				for (let j=1; j<ny; j+=inc) {
					for (let k=1; k<nz; k+=inc) {
						const line = vectorArray[i][j][k];
						const positions = line.geometry.attributes.position.array;
						const fnReturn = vx_vy_vz_hue_func(i,j,k);
						if ( !Array.isArray(fnReturn) ) {
							line.visible = false;
							continue;
						}
						let vx, vy, vz, hue;
						[ vx, vy, vz, hue ] = fnReturn;
						if ( Math.sqrt(vx*vx+vy*vy+vz*vz) < threshold ) {
							line.visible = false;
							continue;
						}
						if ( hue==undefined ) hue = ( vx>0 ) ? 240 : 0;
						const x = hh*i - x0;
						const y = hh*j - y0;
						const z = hh*k - z0;
						positions[0] = x; // point 0
						positions[1] = y;
						positions[2] = z;
						positions[3] = x + vx; // point 1
						positions[4] = y + vy;
						positions[5] = z + vz;
						line.visible = true;
						line.material.color = new THREE.Color(`hsl(${hue},100%,50%)`);
						line.geometry.attributes.position.needsUpdate = true;
					}
				}
        	}
        	lines.visible = true;
		}
	}
	
	// -----------------------  m3js_vField3D function end
	
	
	// -----------------------  m3js_grid3D function  ----------------------------------
	//
	//    ver 0.0.0  2022.06.07 created, last updated on 2022.12.22
	//
	//   grid3D = m3js_grid3D( p_nx, p_ny, p_nz, xBoxSize );
	//      nx:sphere number of x-direction,
	//      ny:sphere number of y-direction, 
	//      nz:sphere number of z-direction,
	//      xBoxSize: x-box size in the threejs-world
	//
	//   scene.add( grid3D );
	//
	//   grid3D.update( field_func, [hue_func] );
	//      field_func: (i,j,k) --> field
	//         (i,j,k) : index of 3D lattice
	//         field : field value of lattce point
	//      hue_func: (i,j,k) --> hue   // if undefined, use inner hue function hue(field))
	//         hue : hsl color index 0,1,2, ... , 359
	//         if typeof(hue)!='number', hue treat as color string
	//
	//   grid3D.setThreshold( th ) 
	//      th: 0.0 ... 1.0 // if diameter of the sphere < hh*th, this sphere set to invisible
	//          default th = 0.2
	//
	//   grid3D.visibility
	//      grid3D.visible = true | false;
	//
		
	const m3js_grid3D = function( p_nx, p_ny, p_nz, xBoxSize ) {
		const gridArray = [];
		const nx = p_nx;
		const ny = p_ny;
		const nz = p_nz;
		const hh = xBoxSize/nx;
		const x0 = xBoxSize/2.0;
		const y0 = hh*ny/2.0;
		const z0 = hh*nz/2.0;
		let threshold = 0.2;
		const grid3D = new THREE.Group();

		const geometry = new THREE.IcosahedronGeometry( 0.5, 1 );
		for ( let i=0; i<nx; i++ ) {
			gridArray[i] = [];
			for ( let j=0; j<ny; j++ ) {
				gridArray[i][j] = [];
				for ( let k=0; k<nz; k++ ) {
					const material = new THREE.MeshBasicMaterial({ color: 0xaaaa00 });
					const icosa = new THREE.Mesh( geometry, material );
					icosa.position.x = i*hh - x0;
					icosa.position.y = j*hh - y0;
					icosa.position.z = k*hh - z0;
					icosa.visible = false;
					gridArray[i][j][k] = icosa;
					grid3D.add( gridArray[i][j][k] );
				}
			}
		}
		
		grid3D.update = grid3D_update; // grid3D_update( fieldFunc, hueFunc )
		grid3D.setThreshold = setThreshold; // setThreshold( th )
		return grid3D;
		
		// private function
	
		function grid3D_update( field_func, hue_func ) {
			const th = threshold*hh;
			const maxMag = 0.9*hh;
			const adeg = 120.0/maxMag;
			let hue;
			for ( let i=0; i<nx; i++ ) {
				for ( let j=0; j<ny; j++ ) {
					for ( let k=0; k<nz; k++ ) {
						const icosa = gridArray[i][j][k];
						const field = field_func(i,j,k);
						const afield = Math.abs(field);
						if ( afield<th ) {
							icosa.visible = false;
							continue;
						}
						let mag = Math.pow(afield,0.5);
						if ( mag>maxMag ) mag = maxMag;
						icosa.scale.set(mag,mag,mag);
						
						if ( hue_func==undefined ) {
							const hue = (field>=0.0) ? Math.floor(120.5-adeg*mag) : Math.floor(120.5+adeg*mag);
							icosa.material.color = new THREE.Color(`hsl(${hue},100%,50%)`);
						} else {
							const hue = hue_func(i,j,k);
							if ( typeof(hue)==='number' ) {
								icosa.material.color = new THREE.Color(`hsl(${hue},100%,50%)`);
							} else {
								icosa.material.color = new THREE.Color( hue );
							}
						}
						icosa.visible = true;
					}
				}
			}
			grid3D.visible = true;
		}
		
		function setThreshold( th ) { 
			threshold = th;
		}
		
	};
	
	// -----------------------  m3js_grid3D function end
	
	
	// -----------------------  m3js_grid2D function  -----------------------------------------
	//
	//    ver 0.0.0  2022.10.08 created, last updated on 2022.12.20
	//
	//  agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
	//      p_nx: number of x-direction lines, p_ny: number of y-direction lines
	//      xBoxSize: x-box size in the threejs-world
	//		[zBoxSize]: z-box size in the threejs-world
	//      [mode]: if mode=='xLineOnly' -->  grid change to x-lines only
	//            if mode=='yLineOnly' -->  grid change to y-lines only
	//            else or undefined --> grid x-lines and y-lines
	//
	//  scene.add( agrid );
	//
	//  agrid.setPallet( pallet, color );
	//      pallet: pallet number 372 ... 399, (371:inner pallet)
	//      color: col = new THREE.Color( color )
	//
	//  agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
	//      z_hue_func(i,j) { ... return [ z, [hue] ]; }
	//          z: threejs world z-position at grid point (i,j)
	//          hue: 0...359 huedeg, 360(black) ...gray...370(white) 371(inner pallet) 372...399 free
	//              or string shch as 'red', '#ff0000', 'rgb(255,0,0)', 'hsl(0,100%,50%)'
	//
	// agrid.visible = false;
	//
	
	const m3js_grid2D = function( p_nx, p_ny, xBoxSize, zBoxSize, mode ) {
		const hueArray = []; // red:hue[deg][0]  green:hue[deg][1]  blue:hue[deg][2]
		const gridArray = [];
		const nx = p_nx;
		const ny = p_ny
		const hh = xBoxSize/nx;
		const x0 = xBoxSize/2.0;
		const y0 = hh*ny/2.0;
		const z0 = ( zBoxSize==undefined ) ? y0 : zBoxSize/2.0;
		const xLineOnly = ( mode==undefined || mode!='xLineOnly' ) ? false : true;
		const yLineOnly = ( mode==undefined || mode!='yLineOnly' ) ? false : true;
		const agrid = new THREE.Group();
		
		if ( hueArray.length<1 ) init_hueArray();
		
		if ( ! yLineOnly ) {
			for (let j=0; j<ny; j++) {
 				const geometry = new THREE.BufferGeometry();
 				const material = new THREE.LineBasicMaterial( { vertexColors: true } );
				const positions = new Float32Array( nx * 3 );
				const colors = new Float32Array( nx * 3 );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setDrawRange( 0, nx );
    			const line = new THREE.Line(geometry,material);
    			gridArray[j] = line;
    			agrid.add( gridArray[j] );
			}
		}
		if ( ! xLineOnly ) {
			for (let i=0; i<nx; i++) {
				const geometry = new THREE.BufferGeometry();
 				const material = new THREE.LineBasicMaterial( { vertexColors: true } );
				const positions = new Float32Array( ny * 3 );
				const colors = new Float32Array( ny * 3 );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setDrawRange( 0, ny );
    			const line = new THREE.Line(geometry,material);
    			gridArray[ny+i] = line;
    			agrid.add( gridArray[ny+i] );
    		}
    	}
    	
    	agrid.setPallet = setPallet; // setPallet( pallet, color )
		agrid.update = gridUpdate; // gridUpdate( fieldFunc, [hueFunc|huedeg|hueStr] )
		agrid.visible = false;
		
		return agrid;


		// private functions
		
		function gridUpdate( z_hue_Func ) {
			if ( ! yLineOnly ) {
				for (let j=0; j<ny; j++) {
					const line = gridArray[j];
					const positions = line.geometry.attributes.position.array;
					const colors = line.geometry.attributes.color.array;
					for (let i= 0; i<nx; i++) {
						let z, hue, r=0.99, g=0.99, b=0.99;
						[ z, hue ] = z_hue_Func(i,j);
						positions[i*3]   = hh*i - x0;
						positions[i*3+1] = hh*j - y0;
						positions[i*3+2] = z;
						
						if ( hue==undefined ) hue = Math.floor(36180.0 - 180.0*(z/z0)) % 360;
						if ( typeof(hue)=='number' ) {
							const deg = Math.floor(hue);
							r = hueArray[deg][0];
							g = hueArray[deg][1];
							b = hueArray[deg][2];
						} else if ( typeof(hue)=='string' ) {
							const col = new THREE.Color( hue );
							r = col.r; g = col.g; b = col.b;
						}
						colors[i*3]   = r;
						colors[i*3+1] = g;
						colors[i*3+2] = b;
					}
					line.geometry.attributes.position.needsUpdate = true;
					line.geometry.attributes.color.needsUpdate = true;
				}
			}
			if ( ! xLineOnly ) {
				for (let i=0; i<nx; i++) {
					const line = gridArray[ny+i];
					const positions = line.geometry.attributes.position.array;
					const colors = line.geometry.attributes.color.array;
					for (let j= 0; j<ny; j++) {
						let z, hue, r=0.99, g=0.99, b=0.99;
						[ z, hue ] = z_hue_Func(i,j);
						positions[j*3]   = hh*i - x0;
						positions[j*3+1] = hh*j - y0;
						positions[j*3+2] = z;
						
						if ( hue==undefined ) hue = Math.floor(36180.0 - 180.0*(z/z0)) % 360;
						if ( typeof(hue)=='number' ) {
							const deg = Math.floor(hue);
							r = hueArray[deg][0];
							g = hueArray[deg][1];
							b = hueArray[deg][2];
						} else if ( typeof(hue)=='string' ) {
							const col = new THREE.Color( hue );
							r = col.r; g = col.g; b = col.b;
						}
						colors[j*3]   = r;
            			colors[j*3+1] = g;
            			colors[j*3+2] = b;
    				}
					line.geometry.attributes.position.needsUpdate = true;
					line.geometry.attributes.color.needsUpdate = true;
				}
			}
			agrid.visible = true;
		}
		
		function setPallet( pallet, color ) {
			const deg = Math.floor(pallet);
			const col = new THREE.Color( color );
			hueArray[deg][0] = col.r;
			hueArray[deg][1] = col.g;
			hueArray[deg][2] = col.b;
		}
		
		function init_hueArray() {
			// deg= 0...359 hue color, 360: black ... gray ...  370:white,
			// 371: inner use, 372...399 as pallete
			for (let deg=0; deg<360; deg++) {
				hueArray[deg] = [];
				const col = new THREE.Color( 'hsl('+deg+',100%,50%)');
				hueArray[deg][0] = col.r;
				hueArray[deg][1] = col.g;
				hueArray[deg][2] = col.b;
			}
			for (let deg=360; deg<400; deg++) {
				hueArray[deg] = [];
				const x = (deg<371) ? (deg-360)*0.1 : 0.0;
				hueArray[deg][0] = x;
				hueArray[deg][1] = x;
				hueArray[deg][2] = x;
			}
		}
		
	};
	
	// -----------------------  m3js_grid2D function end
	
	
	// ----------  dom control
	
	function initDom() {
		document.getElementById("step_button").style.visibility = "hidden";
	}
	
	function reset() {
		resetFlag = 1;
	}
	
	function pause() {
		let btn = document.getElementById("pause_button");

		pauseFlag = (pauseFlag+1)%2; 
		if (pauseFlag==0) btn.innerHTML = "pause"; else btn.innerHTML = "go";
		
		if ( pauseFlag==1 ) {
			document.getElementById("step_button").style.visibility = "visible";
		} else {
			document.getElementById("step_button").style.visibility = "hidden";
		}
	}
	
	function step() {
		stepFlag = 1;
	}
	
	function setTheme() {  // select v_zNu
		v_theme = 0 + document.getElementById("slct_theme").selectedIndex;
		resetFlag = 1;
	}
	
	function setLossSW() {  // select lossSW
		v_lossSW = 0 + document.getElementById("slct_lossSW").selectedIndex;
	}
	
	function setDispMode() {  // select dispMode
		dispMode = 0 + document.getElementById("slct_dispMode").selectedIndex;
		dispModeChanged = true;
	}
	
	function viewHome() {
		viewHomeRequested = true;
	}
	
	
	//--------------------  public  --------------------
	
	return {
		main:			main,			// main()
		
		// dom control
		reset:				reset,				// reset()
		pause:				pause,				// pause()
		step:				step,				// step()
		
		setTheme:			setTheme,			// setTheme()
		setLossSW:			setLossSW,			// setLossSW()
		
		setDispMode:		setDispMode,		// setDispMode()
		viewHome:			viewHome,			// viewHome()
		
	};
	
})(); //==============  tjs107 module end  =========================================================================


// event
const tjs = tjs107;
window.addEventListener('load', tjs.main );


//--------------------  end of javaScript

  </script>
  <style type="text/css">
    body { color:#000000; background-color:#fff8dd;}
  </style>
</head>

<body>
<p>[tjs107] Rabi Oscillation - Quantum Electron Dynamics QED3D</p>
<canvas id="myCanvas" width="500" height="480" ></canvas>
<br>

<span> a H atom in electric field E = E0 sin(ωt)</span>
<!--
<label>theme:</label>
<select id="slct_theme" onChange="tjs.setTheme()">
<option>an electron in the box</option>
<option selected>an electron in parabollic V(r)=k r^2</option>
<option>an electron in the sphere r=6au</option>
<option>H like - Gaussian</option><option>H like - 1s</option><option>H like - 2s</option>
<option>H like - 2px</option><option>H like - 2py</option><option>H like - 2pz</option>
<option>tunnel effect</option><option>double slit</option>
<option>scattering an electron with the sphere</option>
<option>scattering an electron with a proton</option>
</select>
-->
    <span style="margin-right: 20px;"></span>
<label>loss:</label>
<select id="slct_lossSW" onChange="tjs.setLossSW()">
<option selected>off</option><option>on</option>
</select>
    <span style="margin-right: 20px;"></span>
<button onClick="tjs.reset()">reset</button>
<br>

<label>disp mode:</label>
<select id="slct_dispMode" onChange="tjs.setDispMode()">
<option>density = psi^2 dv</option><option selected>phase (angle:Im(psi)/Re(psi))</option>
<option>probability current</option><option>electron cloud</option><option>2D potential V(x,y,0)</option>
<option>2D Re( psi(x,y,0) )</option><option>2D psi density(x,y,0)</option>
<option>2D phase(x,y,0)+V(x,y,0)</option>
<option>density(x,y,z)+V(x,y,0)</option><option selected>phase(x,y,z)+V(x,y,0)</option>
</select>
    <span style="margin-right: 140px;"></span>
<button id="pause_button" onClick="tjs.pause()">pause</button>
    <span style="margin-right: 10px;"></span>
<button id="step_button" onClick="tjs.step()">step</button>
<br>

<button onClick="tjs.viewHome()">return to initial view</button>
    <span style="margin-right: 50px;"></span>
drag mouse to rotate view point

<br>
<span style='color:#ff8800'>
'Rabi Oscillation' ( |1s&gt; &lt;--&gt; |2px&gt; ) appears <br>
 in the electric field E = E0 sin (ωt) at ω ~ 0.403au. </span><br>
search <a href="https://duckduckgo.com/?q=rabi+oscillation&ia=web">Rabi Oscillation</a>
<br>

<hr width="500" align="left" color="#a0a0a0">
<div id="text_caption" ></div>
<hr width="500" align="left" color="#a0a0a0">
<a href="javascript:history.back()">back</a> | <a href="http://mike1336.web.fc2.com/index.html">top</a>
<br>

</body>
</html>

