<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>tjs115_maskEffectMSC2D</title>
  <script src="../lib/three.min.js"></script>
  <script src="../lib/OrbitControls.js"></script>
  <script>

'use strict';

/* =================================================================================================================
//
//  tjs115_maskEffectMSC2D
//    Copyright(C) 2022-2023 Mitsuru Ikeuchi
//    Released under the MIT license ( https://opensource.org/licenses/MIT ) 
//
//    ver 0.0.0  2022.05.17 created, last updated on 2022.05.21
//    ver 0.0.1  2022.10.13 v1, last updated on 2023.01.17
//
//
//------------------------------------------------------------------------------------------------------------------
//
//  SEIR infection Monte-Carlo simulation MCS2D
//
//    S-E-I-R model
//
//      [S] --- beta*I ---> [E] --- sigma ---> [I]--- gamma ---> [R] 
//
//
//    S-E-I-R-S model -- differential equation
//      dS/dt = -beta*S*I
//      dE/dt = beta*S*I - sigma*E
//      dI/dt = sigma*E - gamma*I
//      dR/dt = gamma*I
//    where
//      S: susceptible
//      E: exposed
//      I: infectious
//      R: removed (recover + dead)
//      N = S + E + I + R = constant 
//      beta: infection rate (1/day)
//      sigma: incidence rate (1/day) ~ 1/(mean incubation period)
//      gamma: recovery rate (1/day) ~ 1/(mean infected period)
//
//    basic reproduction number R0
//      R0 = beta*S0/gamma
//
//
//    Monte-Cerlo simulation: mask model
//
//      contacted walkers break to 3 cases              infection probability
//
//        1 both walkers with no mask                      p
//          (walker)       (walker) 
//
//        2 one walker with a mask and other with no mask  p x maskFactor
//          (walker) ]     (walker) or
//          (walker)     [ (walker) 
//
//        3 both walkers with a mask                       p x maskFactor x maskFactor
//          (walker) ]   [ (walker) 
//
//      mask ratio
//
//          maskRatio = (walker with a mask) / ( (walker with a mask) + (walker with no mask) )
//
//
//
//    Monte-Cerlo simulation: procedure in js code
//

	function timeStep() {
		var ipp,st,onset=0;

		nContact = 0;
		for (ipp=1; ipp<=nPop; ipp++) {
			st = status[ipp]; // status[ipp] 0:susceptible, 1:exposed, 2:infectius, 3:removed
			if (st==1) { // 1:exposed  [E] --- sigma ---> [I]
				if (Math.random()<sigma*dt) {
					status[ipp] = 2; // 2:infectius
					onset++;
				}
			} else if (st==2) {  // 2:infectius [I] --- gamma ---> [R]
				if (Math.random()<gamma*dt) {
					status[ipp] = 3; // 3:removed
				}
			}
			moveWalker(ipp);
		}
		return onset;
	}

	function moveWalker(ipp) {
		var dir,ixx,iyy,f;

		dir = Math.floor(Math.random()*4);
		if (dir==0) { // east
			ixx = (ix[ipp]+1)%NNx; iyy = iy[ipp];
		} else if (dir==1) { // west
			ixx = (ix[ipp]-1+NNx)%NNx; iyy = iy[ipp];
		} else if (dir==2) { // north
			ixx = ix[ipp]; iyy = (iy[ipp]+1)%NNy;
		} else if (dir==3) { // south
			ixx = ix[ipp]; iyy = (iy[ipp]-1+NNy)%NNy;
		}
		f = field[ixx][iyy]; // field[][] 1...NNp: particle, 0:free space, -1:wall
		if (f==0) { // free space
			// ipp-walker move
			field[ix[ipp]][iy[ipp]] = 0;
			ix[ipp] = ixx; iy[ipp] = iyy;
			field[ix[ipp]][iy[ipp]] = ipp;
		} else if (f>0) { // other particle
			// contact
			nContact++;
			// status[ipp] 0:susceptible, 1:exposed, 2:infectius, 3:removed
			if (status[ipp]==0 && status[f]==2) { // contact S --> I
				p = 0.5*infectiusProb;
				if (maskq[ipp]==1) p = p*maskFactor;
				if (maskq[f]==1) p = p*maskFactor;
				if (Math.random()<p) {
					status[ipp] = 1; // 1:exposed
				}
			}
			if (status[ipp]==2 && status[f]==0) { // contact S --> I
				p = 0.5*infectiusProb;
				if (maskq[ipp]==1) p = p*maskFactor;
				if (maskq[f]==1) p = p*maskFactor;
				if (Math.random()<p) {
					status[f] = 1; // 1:exposed
				}
			}
		} else if (f==-1) { // wall
			; // ipp-walker not move
		}
	}

//
//    basic reproduction number R0 of this model
//      R0 = numberOfContactToSusceptibleWalkerPerDay*infectiusProb/gamma
//         = ((SS0/(NNx*NNy))/dt)*infectiusProb/gamma
//
//
//------------------------------------------------------------------------------------------------------------------
*/

const maskEffectMSC2D = (function(){ //========================  maskEffectMSC2D Module  ===========================

	const gc_nMax = 100000;					// walker array max
	const gc_ntMax = 21600;					// max times of data record array (step dt)
	const gc_dayvdt = 20;					// 1(day) = gc_dayvdt*dt

	var g_NNp = 40000;						// number of walker
	var g_NNx = 360;						// x-division of the field
	var g_NNy = 360;						// y-division of the field

	var g_sysTime = 0.0;					// (day) system time
	var g_dt = 1.0/gc_dayvdt;				// (day) time step dt
	var g_incubationPeriod = 5.0;			// (day) mean incubation period
	var g_infectedPeriod = 10.0;			// (day) mean infected period
	var g_infectiusProb = 0.04;				// infectius probability per one contact 
	var g_sigma = 1.0/g_incubationPeriod;	// (1/day) incidence rate ~ 1/(mean incubation period) = 1/(5days)
	var g_gamma = 1.0/g_infectedPeriod;		// (1/day) recovery rate ~ 1/(mean infected period) = 1/(10days)

	var g_maskFactor = 0.7;					// (0.0 ... 1.0), infectius probability = maskFactor*(infectiusProb)
	var g_maskRatio = 0.0;					// = (masked person)/(all)

	var g_nPop = g_NNp;						// nPop = S+E+I+R number of walker
	var g_susceptible = g_nPop-30;			// number of susceptible walker
	var g_exposed = 30;						// number of exposed walker
	var g_infectius = 0;					// number of infectius walker
	var g_removed = 0;						// number of removed walker
	var g_onsetPerson = 0;					// number of onset walker
	var g_nContact = 0;						// total number of contact per dt ( nContact ~ NNp*(NNp/(NNx*NNy)) )
	var g_removedRatio = 0.0;
	var g_ss0 = g_susceptible;

	var g_xCanvasSize = 480;				// in pixel
	var g_yCanvasSize = 400;				// in pixel
	var g_yTextSize = 80;					// in pixel
	var g_imageData;						// g_imageData = g_ctx.getImageData(20, 20, NNx, NNy);

	var g_field = dim2Int(g_NNx,g_NNy);		// g_field[i][j]  1...NNp:walker number,  0:free space, -1:wall
	var g_status = dim1Int(gc_nMax);		// g_status[i] 0:susceptible, 1:exposed, 2:infectius, 3:removed
	var g_maskq = dim1Int(gc_nMax);			// g_maskq = 0:with no mask,  1:with a mask
	var g_ix = dim1Int(gc_nMax);			// g_ix[i] x-position of i-th walker
	var g_iy = dim1Int(gc_nMax);			// g_iy[i] y-position of i-th walker

	var g_pS = dim1Int(gc_ntMax);			// (person) susceptible
	var g_pE = dim1Int(gc_ntMax);			// (person) exposed
	var g_pI = dim1Int(gc_ntMax);			// (person) infectius
	var g_pR = dim1Int(gc_ntMax);			// (person) removed
	var g_pN = dim1Int(gc_ntMax);			// (person) total = S+E+I+R
	var g_onsetvdt = dim1Int(gc_ntMax);		// (person) onset person per dt
	var g_onsetvday = dim1Int(gc_ntMax);	// (person) onset person per day
	var g_nContactvdt = dim1Int(gc_ntMax);	// number of contact per dt

	function dim1Int(n) {
		var i, a=[];

		for (i=0; i<n; i++) {  
			a[i] = 0;
		}
		return a;
	}

	function dim2Int(ni,nj) {
		var i,j, a=[];

		for (i=0; i<ni; i++) {  
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = 0;
			}
		}
		return a;
	}


	//--------------------  set initial condition  --------------------

	function setInitialCondition(v_infectiusProb,v_sigma,v_gamma,v_maskFactor,v_maskRatio) {

		g_NNp = 40000;						// nPop = S+E+I+R number of walkers
		g_removedRatio = 0.0;				// initial removed ratio: removed(t==0) = removedRatio*N
		setParam(v_infectiusProb,v_sigma,v_gamma,v_maskFactor,v_maskRatio);

		g_sysTime = 0;						// (day) system time

		g_nPop = g_NNp;						// nPop = S + E + I + R
		g_removed = Math.floor(g_nPop*g_removedRatio);	// number of removed walkers
		g_exposed = 30;						// number of exposed walkers
		g_susceptible = g_nPop - g_removed - g_exposed;	// number of susceptible walkers
		g_infectius = 0;					// number of infectius walkers
		g_onsetPerson = 0;					// number of onset walker
		g_nContact = 0;						// number of contact per dt
		g_ss0 = g_susceptible;				// S(0): initial number of susceptible walkers

		clearField();
		clearPop();
		setWalkers(g_nPop,g_exposed);
		setMask(g_nPop,g_maskRatio);
	}

	function setParam(v_infectiusProb,v_sigma,v_gamma,v_maskFactor,v_maskRatio) {
		g_infectiusProb = v_infectiusProb;// infectius probability per one contact
		g_sigma = v_sigma;				// (1/day) incidence rate ~ 1/(mean incubation period) = 1/(5days)
		g_gamma = v_gamma;				// (1/day) recovery rate ~ 1/(mean infected period) = 1/(10days)
		g_maskFactor = v_maskFactor;	// (0.0 ... 1.0), infectius probability = maskFactor*(infectiusProb)
		g_maskRatio = v_maskRatio;		// = (masked person)/(all)

		setMask(g_nPop,g_maskRatio);
	}

	function clearField() {
		var i,j,nnx=g_NNx,nny=g_NNy;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				g_field[i][j] = 0;
			}
		}
	}

	function clearPop() {
		var i,nt=gc_ntMax;

		for (i=0; i<nt; i++) {
			g_pS[i] = 0;
			g_pE[i] = 0;
			g_pI[i] = 0;
			g_pR[i] = 0;
			g_pN[i] = 0;
			g_onsetvdt[i] = 0;
			g_onsetvday[i] = 0;
			g_nContactvdt[i] = 0;
		}
	}

	function setWalkers(nn, initExposedNum) {
		var i,ipp,x,y,nnx=g_NNx,nny=g_NNy, rr0;

		rr0 = nn*g_maskRatio;
		// set susceptible nn walkers
		for (i=1; i<=nn; i++) {
			do {
				x = Math.floor(nnx*Math.random());
				y = Math.floor(nny*Math.random());
			} while (g_field[x][y]!=0); // g_field[][]: free space: 0, walker:1...NNp-1
			g_field[x][y] = i;
			g_ix[i] = x;
			g_iy[i] = y;
			g_status[i] = 0; // 0:susceptible

			if (i<=rr0) {
				g_maskq[i] = 1; // with a mask
			} else {
				g_maskq[i] = 0; // with no mask
			}
		}

		// set exposed initExposedNum walkers
		for (i=0; i<initExposedNum; i++) {
			do {
				ipp = Math.floor(nn*Math.random()) + 1;
			} while (g_status[ipp]!=0); //g_status[ipp] 0:susceptible, 1:exposed, 2:infectius, 3:removed
			g_status[ipp] = 1; // 1:exposed
		}
	}

	function setMask(nn,maskRatio) {
		var i, nMask = nn*maskRatio;

		for (i=1; i<=nn; i++) {

			if (i<=nMask) {
				g_maskq[i] = 1; // with a mask
			} else {
				g_maskq[i] = 0; // with no mask
			}
		}
	}


	//--------------------  time evolution  --------------------

	function timeEvolution(nCalc) {
		var i,it;

		for (i=0; i<nCalc; i++) {
			it = Math.floor(g_sysTime/g_dt);
			memoSEIRN(it); // set g_pS[it],g_pE[it],g_pI[it],g_pR[it],g_pN[it]

			g_sysTime += g_dt;
			g_onsetPerson = timeStep();
		}
	}

	function timeStep() {
		var ipp,nnp=g_NNp,st,onset=0;

		g_nContact = 0;
		for (ipp=1; ipp<=nnp; ipp++) {
			st = g_status[ipp]; // g_status[ipp] 0:susceptible, 1:exposed, 2:infectius, 3:removed
			if (st==1) { // 1:exposed  [E] --- sigma ---> [I]
				if (Math.random()<g_sigma*g_dt) {
					g_status[ipp] = 2; // 2:infectius
					onset++;
				}
			} else if (st==2) {  // 2:infectius [I] --- gamma ---> [R]
				if (Math.random()<g_gamma*g_dt) {
					g_status[ipp] = 3; // 3:removed
				}
			}
			moveWalker(ipp);
		}
		return onset;
	}

	function moveWalker(ipp) {
		var dir,ixx,iyy, f,p;

		dir = Math.floor(Math.random()*4);
		if (dir==0) { // east
			ixx = (g_ix[ipp]+1)%g_NNx; iyy = g_iy[ipp];
		} else if (dir==1) { // west
			ixx = (g_ix[ipp]-1+g_NNx)%g_NNx; iyy = g_iy[ipp];
		} else if (dir==2) { // north
			ixx = g_ix[ipp]; iyy = (g_iy[ipp]+1)%g_NNy;
		} else if (dir==3) { // south
			ixx = g_ix[ipp]; iyy = (g_iy[ipp]-1+g_NNy)%g_NNy;
		}
		f = g_field[ixx][iyy]; // g_field[][] 1...NNp: particle, 0:free space, -1:wall
		if (f==0) { // free space
			// ipp-walker move
			g_field[g_ix[ipp]][g_iy[ipp]] = 0;
			g_ix[ipp] = ixx; g_iy[ipp] = iyy;
			g_field[g_ix[ipp]][g_iy[ipp]] = ipp;
		} else if (f>0) { // other particle
			// contact
			g_nContact++;
			// g_status[ipp] 0:susceptible, 1:exposed, 2:infectius, 3:removed
			if (g_status[ipp]==0 && g_status[f]==2) { // contact S --> I
				p = 0.5*g_infectiusProb;
				if (g_maskq[ipp]==1) p = p*g_maskFactor;
				if (g_maskq[f]==1) p = p*g_maskFactor;
				if (Math.random()<p) {
					g_status[ipp] = 1; // 1:exposed
				}
			}
			if (g_status[ipp]==2 && g_status[f]==0) { // contact S --> I
				p = 0.5*g_infectiusProb;
				if (g_maskq[ipp]==1) p = p*g_maskFactor;
				if (g_maskq[f]==1) p = p*g_maskFactor;
				if (Math.random()<p) {
					g_status[f] = 1; // 1:exposed
				}
			}
		} else if (f==-1) { // wall
			; // ipp-walker not move
		}
	}

	function memoSEIRN(i) {
		var ipp,ss,ee,ii,rr,nn,st,nnp=g_NNp;

		ss = 0;
		ee = 0;
		ii = 0;
		rr = 0;
		nn = 0;
		for (ipp=1; ipp<=nnp; ipp++) {
			st = g_status[ipp];
			if (st==0) {
				ss++;
			} else if (st==1) {
				ee++;
			} else if (st==2) {
				ii++;
			} else if (st==3) {
				rr++;
			}
		}
		g_susceptible = ss;
		g_exposed = ee;
		g_infectius = ii;
		g_removed = rr;
		g_nPop = ss + ee + ii + rr;

		if (i>gc_ntMax-1) return;

		g_pS[i] = g_susceptible;
		g_pE[i] = g_exposed;
		g_pI[i] = g_infectius;
		g_pR[i] = g_removed;
		g_pN[i] = g_nPop;
		g_onsetvdt[i] = g_onsetPerson;
		setPoday(i);
		g_nContactvdt[i] = g_nContact;
	}

	function setPoday(it) {
		var i,ii,s;

		s = 0;
		for (i=-19; i<=0; i++) {
			ii = it + i;
			if (ii>=0) {
				s += g_onsetvdt[ii];
			}
		}
		g_onsetvday[it] = s;
	}


	//--------------------  set image data  --------------------

	function setImageData(ctx) {
		if ( setImageData.isSet==false ) {
			g_imageData = ctx.getImageData(20, 20, g_NNx, g_NNy);
			setImageDataAlhpa();
			setImageData.isSet = true;
		}
	}
	setImageData.isSet = false;

	function setImageDataAlhpa() {
		var i,j,idx,nnx=g_NNx,nny=g_NNy, data;

		data = g_imageData.data;
		for (j=0; j<nny; j++) {
			for (i = 0; i<nnx; i++) {
				idx = (j*nnx+i)*4;
				data[idx] = 0;
				data[++idx] = 0;
				data[++idx] = 0;
				data[++idx] = 255;
			}
		}
	}


	//--------------------  draw  --------------------

	function draw(ctx, drawMode,timeRange) {
		var xp=60,yp=30, iMax, piMax;
		
		if ( setImageData.isSet==false ) setImageData(ctx);

		//ctx.clearRect(0, 0, g_xCanvasSize, g_yCanvasSize);

		if (drawMode==0) {
			drawField(ctx);
			drawCaption(ctx);
		} else if (drawMode==1) {
			drawFieldx5PartialView(ctx, 20,20,180-32,180-32);
			drawCaption(ctx);
		} else if (drawMode==2) {
			plotSEIR(ctx, xp,yp,timeRange);
		} else if (drawMode==3) {
			logPlotSEIR(ctx, xp,yp,timeRange);
		}

		ctx.fillStyle = "rgb(240,240,240)"; //background color
		ctx.fillRect(0, g_yCanvasSize,g_xCanvasSize, g_yTextSize); //clear text area

		ctx.fillStyle = "rgb(0, 0, 0)";
		ctx.fillText("time = "+g_sysTime.toFixed(2)+" (day)", 20, g_yCanvasSize+24);
		ctx.fillText("contact = "+g_nContact+" (per dt)", 220, g_yCanvasSize+24);
		ctx.fillText("N ="+g_nPop, 20, g_yCanvasSize+44);
		ctx.fillText("infection Prob. = "+g_infectiusProb.toFixed(3), 220, g_yCanvasSize+44);
		ctx.fillText("sigma = "+g_sigma.toFixed(2)+" (1/day)", 20, g_yCanvasSize+64);
		ctx.fillText("gamma = "+g_gamma.toFixed(2)+" (1/day)", 220, g_yCanvasSize+64);
		/*
		document.getElementById("text_caption").innerHTML =
			"Press the reset button when the parameters are changed.<br>"
			+"maskFactor : infectiuon probability(with a mask) = g_maskFactor*infectiusProb<br>"
			+"maskRatio = (with a mask)/(all).<br>"
			+"basic reproduction number R0(with no mask) = "
			+((g_ss0/(g_NNx*g_NNy))/g_dt*g_infectiusProb/g_gamma).toFixed(2);
		*/
	}

	function drawCaption(ctx) {
		drawText(ctx, "S ="+g_susceptible, 20, 18, "rgb(0, 0, 250)");
		drawText(ctx, "E ="+g_exposed, 120, 18, "rgb(160, 160, 0)");
		drawText(ctx, "I ="+g_infectius, 220, 18, "rgb(250, 0, 0)");
		drawText(ctx, "R ="+g_removed, 320, 18, "rgb(0, 160, 0)");
		drawText(ctx, "N ="+g_nPop, 20, 397, "rgb(0, 0, 0)");
	}

	// --- field

	function drawField(ctx) {
		var i,j,jj,idx,nnx=g_NNx,nny=g_NNy, data,r,g,b, f,st;

		data = g_imageData.data;
		for (j=0; j<nny; j++) {
			jj = nny-j-1;
			for (i = 0; i<nnx; i++) {
				idx = (jj*nnx+i)*4;
				f = g_field[i][j];
				r = 60; g = 60; b = 60;
				if (f>0) {
					st = g_status[f];
					if (st==0) { // susceptible
						r = 80; g = 80; b = 255;
					} else if (st==1) { // exposed
						r = 200; g = 200; b = 0;
					} else if (st==2) { // infectius
						r = 255; g = 120; b = 120;
					} else if (st==3) { // removed
						r = 0; g = 160; b = 0;
					}
				} else if (f==-1) {
					r = 0; g = 0; b = 0;
				}
				data[idx] = r;
				data[++idx] = g;
				data[++idx] = b;
			}
		}
		ctx.putImageData(g_imageData, 20, 20);
	}

	function drawFieldx5PartialView(ctx, xp,yp,ix0,iy0) {
		var i,j, f,st, colr;

		ctx.fillStyle = "rgb(60,60,60)";
		ctx.fillRect(xp,yp,g_NNx,g_NNy);

		for (i=0; i<72; i++) {
			for (j=0; j<72; j++) {
				f = g_field[ix0+i][iy0+j];
				colr = "rgb(60,60,60)";
				if (f>0) {
					st = g_status[f];
					if (st==0) { // susceptible
						colr = "rgb(80,80,255)";
					} else if (st==1) { // exposed
						colr = "rgb(200,200,0)";
					} else if (st==2) { // infectius
						colr = "rgb(255,120,120)";
					} else if (st==3) { // removed
						colr = "rgb(0,160,0)";
					}
					drawDisc(ctx, xp+i*5+2.5,yp+(71-j)*5+2.5,2.5,colr);
				} else if (f==-1) {
					colr = "rgb(0,0,0)";
				}
			}
		}
	}

	function drawDisc(ctx, x,y,r,color) {
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.arc(x, y, r, 0, 2*Math.PI, false);
		ctx.fill();
	}

	// ---  plot

	function plotSEIR(ctx, xp,yp,timeRange) {
		var mag = 300.0/g_nPop, m=Math.floor(gc_dayvdt*timeRange/360);

		//drawGrid(xp,yp,xLen,yLen,xDiv,yDiv,x0Str,xMaxStr,y0Str,yMaxStr,color)
		drawGrid(ctx, xp,yp,360,300,30,30,"0",timeRange+"(day)","0",""+g_nPop,"rgb(120,120,120)");

		drawText(ctx, "Susceptible", xp+20, yp-5, "rgb(0,0,250)");
		drawText(ctx, "Exposed", xp+70, yp+20, "rgb(160,160,0)");
		drawText(ctx, "Infectious", xp+120, yp-5, "rgb(250,0,0)");
		drawText(ctx, "Removed", xp+220, yp-5, "rgb(0,160,0)");
		drawText(ctx, "Population", xp+160, yp+20, "rgb(0,0,0)");
		drawText(ctx, "plot SEIR", xp+20, yp+340, "rgb(0,0,0)");
		drawText(ctx, "daily new cases x 50", xp+140, yp+40, "rgb(250,0,250)");

		plotFunc(ctx, xp,yp,g_pS,m,mag,"rgb(0,0,250)");
		plotFunc(ctx, xp,yp,g_pE,m,mag,"rgb(160,160,0)");
		plotFunc(ctx, xp,yp,g_pI,m,mag,"rgb(250,0,0)");
		plotFunc(ctx, xp,yp,g_pR,m,mag,"rgb(0,160,0)");
		plotFunc(ctx, xp,yp,g_pN,m,mag,"rgb(0,0,0)");
		plotFunc(ctx, xp,yp,g_onsetvday,m,mag*50,"rgb(250,0,250)");
	}

	function plotFunc(ctx, xp,yp,pop,m,mag,colr) {
		ctx.strokeStyle = colr;
		ctx.beginPath();
		for (var i=0; i<360; i++) {
			ctx.lineTo(xp+i, yp+300-mag*pop[i*m]);
		}
		ctx.stroke();
	}

	function logPlotSEIR(ctx, xp,yp,timeRange) {
		var m=Math.floor(gc_dayvdt*timeRange/360);

		//drawGrid(xp,yp,xLen,yLen,xDiv,yDiv,x0Str,xMaxStr,y0Str,yMaxStr,color)
		drawGrid(ctx, xp,yp,360,300,30,60,"0",timeRange+"(day)","10^0","10^5","rgb(120,120,120)");

		drawText(ctx, "Susceptible", xp+20, yp-5, "rgb(0,0,250)");
		drawText(ctx, "Exposed", xp+70, yp+20, "rgb(160,160,0)");
		drawText(ctx, "Infectious", xp+120, yp-5, "rgb(250,0,0)");
		drawText(ctx, "Removed", xp+220, yp-5, "rgb(0,160,0)");
		drawText(ctx, "Population", xp+160, yp+20, "rgb(0,0,0)");
		drawText(ctx, "log plot SEIR", xp+20, yp+340, "rgb(0,0,0)");
		drawText(ctx, "daily new cases", xp+140, yp+40, "rgb(250,0,250)");

		plotLog10Func(ctx, xp,yp,g_pS,m,"rgb(0,0,250)");
		plotLog10Func(ctx, xp,yp,g_pE,m,"rgb(160,160,0)");
		plotLog10Func(ctx, xp,yp,g_pI,m,"rgb(250,0,0)");
		plotLog10Func(ctx, xp,yp,g_pR,m,"rgb(0,160,0)");
		plotLog10Func(ctx, xp,yp,g_pN,m,"rgb(0,0,0)");
		plotLog10Func(ctx, xp,yp,g_onsetvday,m,"rgb(250,0,250)");
	}

	function plotLog10Func(ctx, xp,yp,pop,m,colr) {
		var i, p,logp;

		ctx.strokeStyle = colr;
		ctx.beginPath();
		for (i=0; i<360; i++) {
			p = pop[i*m]; 
			if (p<=0.0) p = 0.1;
			logp = Math.log10(p);
			if (logp>-0.5) ctx.lineTo(xp+i, yp+300-60.0*logp);
		}
		ctx.stroke();
	}

	function drawGrid(ctx, xp,yp,xLen,yLen,xDiv,yDiv,x0Str,xMaxStr,y0Str,yMaxStr,color) {
		var i,j;

		ctx.strokeStyle = color;
		ctx.fillStyle = color;
		ctx.strokeRect(xp,yp,xLen,yLen);

		for (i=0; i<xLen; i+=xDiv) {
			drawLine(ctx, xp+i,yp, xp+i, yp+yLen,color);
		}
		for (j=0; j<yLen; j+=yDiv) {
			drawLine(ctx, xp,yp+yLen-j, xp+xLen, yp+yLen-j,color);
		}
		ctx.fillText(x0Str, xp-5, yp+yLen+20);
		ctx.fillText(xMaxStr, xp+xLen-xMaxStr.length*4, yp+yLen+20);
		ctx.fillText(y0Str, xp-y0Str.length*8-8, yp+yLen+5);
		ctx.fillText(yMaxStr, xp-yMaxStr.length*8-8, yp+5);
	}

	 function drawLine(ctx, x1, y1, x2, y2, color) {
	 	ctx.strokeStyle = color;
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();
	}

	function drawText(ctx, txt, x, y, color) {
		ctx.fillStyle = color;
		ctx.fillText(txt, x, y);
	}


	//--------------------  data output  --------------------

	function outputTextArea(outputSW, timeRange) {
		// outputSW:  0:textarea clear,  1:output text data
		var i,j, rr0, str;

		if (outputSW==0) {
			str = "";
		} else if (outputSW==1) {
			rr0 = +(g_ss0/(g_NNx*g_NNy))/g_dt*g_infectiusProb/g_gamma;
			str = "infectiusProb = "+g_infectiusProb.toFixed(5)
					+ ",  sigma = "+g_sigma.toFixed(2)+",  gamma = "+g_gamma.toFixed(2)+" \n";
			str += "R0 = "+rr0.toFixed(2)+" \n";
			str += "S(0) = "+g_pS[0].toFixed(1)+",  E(0) = "+g_pE[0].toFixed(1)
				+",  I(0) = "+g_pI[0].toFixed(1)+" \n";
			str += " \n";
			str += " day,  S(t),  E(t),  I(t),  R(t),  NewCase(t)\n";
			for (i=0; i<timeRange; i++) {
				j = i*gc_dayvdt;
				str += " "+(j*g_dt).toFixed(1)+",  "
				+g_pS[j].toFixed(1)+",  "
				+g_pE[j].toFixed(1)+",  "
				+g_pI[j].toFixed(1)+",  "
				+g_pR[j].toFixed(1)+",  "
				+g_onsetvday[j].toFixed(1)+"\n";
			}
		}
		document.getElementById("outputText").innerHTML = str;
	}
	

	//--------------------  public  --------------------

	return {
		init:			setInitialCondition,// setInitialCondition( infectiusProb, sigma, gamma, maskFactor, maskRatio )
		setParam:		setParam,			// setParam( infectiusProb, sigma, gamma, maskFactor, maskRatio )
		evolve:			timeEvolution,		// timeEvolution( nCalc )
		draw:			draw, 				// draw( ctx, drawMode, timeRange )
		
		getSysParam:	function() { return [ g_NNx, g_NNy, g_dt, g_NNp, g_ss0 ]; },
		getNow:			function() { return [ g_sysTime, g_nContact, g_susceptible ]; },
		getNowSEIRN:	function() { return [ g_susceptible, g_exposed, g_infectius, g_removed, g_nPop ]; },
		getSEIRN:		function(i) { return [ g_pS[i], g_pE[i], g_pI[i], g_pR[i], g_pN[i], g_onsetvday[i] ]; },
		getWalker:		function(i) { return [ g_status[i], g_ix[i], g_iy[i], g_maskq[i] ]; },
		outputTextArea: outputTextArea,		// outputTextArea(outputSW, timeRange)
		
	};

})(); //==============  maskEffectMSC2D end  =======================================================================


const tjs115 = (function(){ //========================  tjs Module  ================================================

	// theModule.init(v_infectiusProb,v_sigma,v_gamma,v_maskFactor,v_maskRatio)
	// theModule.setParam(v_infectiusProb,v_sigma,v_gamma,v_maskFactor,v_maskRatio)
	// theModule.evolve(nCalc)
	// theModule.draw(ctx,drawMode,timeRange)
	// theModule.outputTextArea(outputFlag, timeRange)

	const theModule = maskEffectMSC2D;
	
	let theme = 0;			// no use
	
	let v_infectiusProb = 0.04;	// infectius probability per one contact ;
	let v_sigma = 0.2;			// (1/day) incidence rate ~ 1/(mean incubation period) = 1/(5days)
	let v_gamma = 0.1;			// (1/day) recovery rate ~ 1/(mean infected period) = 1/(10days)
	let v_popDens = 40000;		// = S+E+I+R number of walkers
	let v_removedRatio = 0.0;	// for vaccinated ratio: inirial R(0) = removedRatio*nPop 
	let v_maskFactor = 0.7;		// (0.0 ... 1.0), infectius probability = maskFactor*(infectiusProb)
	let v_maskRatio = 0.0;		// = (masked person)/(all)
	let nCalc = 1;
	let drawMode = 2;			// 0:SEIR-walkers 1:SEIR-warkers x5 2:plot S-I-R, 3:plot log S-I-R
	let outputFlag = 0;			// 0:do nothing, 1: output S-I-R data
	let timeRange = 360;		// 180, 360, 720, 1080 (days)

	let p_nx, p_ny, p_dt, p_nPop, p_ss0; // <-- theModule.getSysParam();
	let p_time, p_nContact, p_susceptible; // <-- theModule.getNow();
	// walker status   0:susceptible, 1:exposed, 2:infectius, 3:removed
	const statusColor = [ "#6666ff", "#ffff00", "#ff6666", "#00ff00" ];
	let resetFlag = 0;
	let pauseFlag = 0;
	let stepFlag = 0;
	let changeFlag = 0;
	let dispModeChanged = true;
	let viewHomeRequested = false;
	let legendFlag = true;
	let count = 0; // animate count
	
	// sizes in the threejs world
	const xBoxSize = 600;
	let hh, x0, y0, z0;

	// threejs world object
	let cnvsprite;
	let walkers;

	// three.js , OrbitControls.js
	const width = 500;
	const height = 480;
	const r_camera = 1260.0;
	let renderer;
	let scene;
	let camera;
	let controls;
	
	
	// -------------------- main
	
	function main() {
		// construct renderer
		renderer = new THREE.WebGLRenderer({
					//canvas: document.querySelector('#myCanvas') });
					canvas: document.querySelector('#myCanvas'), antialias: true });
		renderer.setSize(width, height);
		
		// camera
		camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000);
		camera.position.set(0, 0, r_camera);
		controls = new THREE.OrbitControls(camera,renderer.domElement); // lib/OrbitControls.js
		
		initDom();

		constructScene();
		animate();
	}


	function constructScene() {

		// initialize MD
		theModule.init(v_infectiusProb,v_sigma,v_gamma,v_maskFactor,v_maskRatio);
		[ p_nx, p_ny, p_dt, p_nPop, p_ss0 ] = theModule.getSysParam();
		hh = xBoxSize/p_nx;
		x0 = xBoxSize/2, y0 = p_ny*hh/2, z0 = 0;

		// scene
		scene = new THREE.Scene();
 
		camera.position.set(0, 0, r_camera); 
 
		// light - DirectionalLight
		const directionalLight = new THREE.DirectionalLight(0xFFFFFF,0.7);
		directionalLight.position.set(1, 1, 1);
		scene.add(directionalLight);
		// light - AmbientLight
		const light = new THREE.AmbientLight(0xFFFFFF, 0.3);
		scene.add(light);
		
		
		// walkers
		walkers = addWalkers( scene, v_popDens, 3.8*hh );
		
		// canvas sprite
		// cnvsprite = m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight )
		cnvsprite = m3js_canvasSprite( 600, 600, 470 );
		cnvsprite.position.set(0,0,0);
		scene.add( cnvsprite );

	}
	
	
	// loop animation
	function animate() {
		
		// select theme
		if ( resetFlag==1 ) {
			resetFlag = 0;
			constructScene();
			dispModeChanged = true;
			count = 0;
		}
		
		if ( changeFlag==1 ) {
			changeFlag = 0;
			theModule.setParam(v_infectiusProb,v_sigma,v_gamma,v_maskFactor,v_maskRatio);
		}
		
		if ( viewHomeRequested ) {
			camera.position.set(0, 0, r_camera);
			viewHomeRequested = false;
		}
		
		if ( dispModeChanged ) {
			cnvsprite.visible = false;
			walkers.visible = false;
		}
		
		if ( outputFlag==1 ) {
			theModule.outputTextArea(outputFlag, timeRange);
			outputFlag = 0;
		}
		
		if ( pauseFlag==0 ) {
			theModule.evolve(nCalc);
			[ p_time, p_nContact, p_susceptible ] = theModule.getNow();
		} else if ( pauseFlag==1 && stepFlag==1 ) {
			stepFlag = 0;
			theModule.evolve( 1 );
			[ p_time, p_nContact, p_susceptible ] = theModule.getNow();
		}
		
		
		// threejs walker update
		if ( drawMode==4 ) {
			walkers.update( v_popDens, hh, x0, y0, z0 );
		}
		
		// sprite update
		if ( drawMode<4 ) {
			// cnvsprite.update( drawFunc )
			cnvsprite.update(
				function( sprite ) { // drawFunc(sprite)
					const ctx = sprite.ctx;
					const canvasWidth = sprite.canvas.width;
					const canvasHeight = sprite.canvas.height;
					
					// clear canvas
					ctx.fillStyle = "#bbbbbb";
					ctx.fillRect( 0, 0, canvasWidth, canvasHeight);
					
					theModule.draw( ctx, drawMode, timeRange, outputFlag );
					outputFlag = 0;
				}
			);
		}
		
		
		// output to innerHTML
		if (count % 5 == 0) {
			const msg = "time ="+p_time.toFixed(2)+"(day), N ="+v_popDens
				+ ", contact/dt ="+p_nContact+"<br>"
				+ "basic reproduction number R0 = "
				+ ((p_ss0/(p_nx*p_ny))/p_dt*v_infectiusProb/v_gamma).toFixed(2)+"<br>"
				+ "reproduction number at present Rp = "
				+ ((p_susceptible/(p_nx*p_ny))/p_dt*v_infectiusProb/v_gamma).toFixed(2)+"<br>";
			const msg2 = "maskFactor : infectiuon probability(with a mask) = g_maskFactor*infectiusProb<br>"
				+"maskRatio = (with a mask)/(all).<br>";
			document.getElementById("text_caption").innerHTML = msg + msg2;
			
			if ( legendFlag && drawMode==4 ) {
				let ss, ee, ii, rr, nn;
				[ ss, ee, ii, rr, nn ] = theModule.getNowSEIRN();
				let caption = "<span style='margin-right: 30px;'></span>"
					+ "<span style='color:"+statusColor[0]+"'>S="+ss+"</span>" + ", "
					+ "<span style='color:"+statusColor[1]+"'>E="+ee+"</span>" + ", "
					+ "<span style='color:"+statusColor[2]+"'>I="+ii+"</span>" + ", "
					+ "<span style='color:"+statusColor[3]+"'>R="+rr+"</span>" + ", "
					+ "<span style='color:#dddddd'>N="+nn+"</span>"
				document.getElementById('textOnCanvas').innerHTML = caption;
			} else {
				document.getElementById('textOnCanvas').innerHTML = "";
			}
			
		}

		
		count += 1;
		controls.update();
		renderer.render(scene, camera);
		requestAnimationFrame(animate);
	}
	
	
	
	// -----------------------  walkers (points)
	//
	//    ver 0.0.0  2022.05.16 created, last updated on 2022.05.17
	//
	// walkers = addWalkers( scene, nnpMax, pointSize )
	//     scene: threejs world scene
	//     nnpMax: max. number of walkers
	//     pointSize; point size in threejs world
	// scene.add( walkers );
	//
	// walkers.update( nnp, hh, x0, y0, z0 )
	//     nnp:  number of walkers
	//     hh: xBoxSize/nx
	//		x0: xBoxSize/2,  y0:yBoxSize/2,  z0:zBoxSize/2
	// 
	// walkers.visible = true|false;
	//
	/* sample code:
			let walkers;
	
			// add walkers
			walkers = addWalkers( scene, nnpMax, pointSize );

			// update walkers
			walkers.update( nnp, hh, x0, y0, z0 );
			
			// visibility
			cnvsprite.visible = false;
	*/

	function addWalkers( scene, nnpMax, pointSize ) {
		const geometry = new THREE.BufferGeometry();
		const nn = nnpMax;
		const positions = new Float32Array( nn * 3 );
		const colors = new Float32Array( nn * 3 );
		geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
		geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
		const material = new THREE.PointsMaterial( { size: pointSize, vertexColors: true } );
		const walkers = new THREE.Points( geometry, material );
		scene.add( walkers );
		walkers.visible = false;
		walkers.update = updateWalkers; // updateWalkers( nnp, hh, x0, y0, z0 )
		return walkers; 


		function updateWalkers( nnp, hh, x0, y0, z0 ) {
			const positions = walkers.geometry.attributes.position.array;
			const colors = walkers.geometry.attributes.color.array;
			const colorData = 
				// walker status   0:susceptible, 1:exposed, 2:infectius, 3:removed
				[ [ 0.20, 0.20, 0.99 ], [ 0.99, 0.99, 0.20 ], [ 0.99, 0.20, 0.20 ], [ 0.20, 0.99, 0.20 ] ];
			let st, ix, iy, msk;
			for ( let i=0; i<nn; i++ ) {
				[ st, ix, iy, msk ] = theModule.getWalker(i);
				positions[ 3 * i ] = ix*hh-x0;
				positions[ 3 * i + 1 ] = iy*hh-y0;
				positions[ 3 * i + 2 ] = z0;

				colors[ 3 * i ] = colorData[st][0]; // red
				colors[ 3 * i + 1 ] = colorData[st][1]; // green
				colors[ 3 * i + 2 ] = colorData[st][2]; // blue
			}
			walkers.visible = true;
			walkers.geometry.attributes.position.needsUpdate = true;
			walkers.geometry.attributes.color.needsUpdate = true;
		}
	}
	
	
	// -----------------------  m3js_canvasSprite function  ------------------------------
	//
	//    ver 0.0.0  2022.05.06 created, last updated on 2022.12.19
	//
	// cnvsprite = m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight )
	//     spriteWidth: world width of sprite 3D object
	//     spriteHeight: world height of sprite 3D object
	//     canvasHeight: canvas height in pixel
	// scene.add( cnvsprite );
	//
	// cnvsprite.update( drawFunc )
	//     sprite: sprite object
	//     drawFunc: draw(sprite)
	// 
	// cnvsprite.visible = true | false;
	//
	
	function m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight ) {
		// canvas setup
		const canvasWidth = Math.ceil(spriteWidth*canvasHeight/spriteHeight);
		const canvas = document.createElement("canvas");
		canvas.width  = canvasWidth;
		canvas.height = canvasHeight;
		const ctx = canvas.getContext('2d');
		ctx.font = "16px 'sans-serif'";
		ctx.textBaseline = "bottom";
		ctx.textAlign = "left";
		
		// texture <-- canvas
		const texture = new THREE.Texture(canvas);
		texture.needsUpdate = true;
		
		// sprite <-- texture
		const spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
		const sprite = new THREE.Sprite( spriteMaterial );
		
		sprite.scale.set(spriteWidth, spriteHeight, 1);
		sprite.canvas = canvas;
		sprite.ctx = ctx;
		sprite.texture = texture;
		sprite.visible = false;
		sprite.update =
			function( drawFunc ) {
				drawFunc(sprite);
				sprite.visible = true;
				sprite.texture.needsUpdate = true;
			};
		return sprite;
	}
	
	// -----------------------  m3js_canvasSprite function end
	
	
	// ----------  dom control

	function initDom() {
		document.getElementById("step_button").style.visibility = "hidden";
	}
	
	function reset() {
		resetFlag = 1;
	}
	
	function pause() {
		let btn = document.getElementById("pause_button");

		pauseFlag = (pauseFlag+1)%2; 
		if (pauseFlag==0) btn.innerHTML = "pause"; else btn.innerHTML = "go";
		
		if ( pauseFlag==1 ) {
			document.getElementById("step_button").style.visibility = "visible";
		} else {
			document.getElementById("step_button").style.visibility = "hidden";
		}
	}
	
	function step() {
		stepFlag = 1;
	}

	function setInfectProb() {
		const p = 0 + document.getElementById("range_infectiusProb").value;
		v_infectiusProb = 0.001*p;
		document.getElementById("text_infectiusProb").innerHTML = " " + v_infectiusProb.toFixed(3);
		changeFlag = 1;
	}

	function setSigma() {
		const s = 0 + document.getElementById("range_sigma").value;
		v_sigma = 0.005*s;
		document.getElementById("text_sigma").innerHTML =
			" " + v_sigma.toFixed(2) + " (1/ " + (1.0/v_sigma).toFixed(1) + " day)";
		changeFlag = 1;
	}

	function setGamma() {
		const g = 0 + document.getElementById("range_gamma").value;
		v_gamma = 0.005*g;
		document.getElementById("text_gamma").innerHTML =
			" " + v_gamma.toFixed(2) + " (1/ " + (1.0/v_gamma).toFixed(1) + " day)";
		changeFlag = 1;
	}

	function setMaskFactor() {
		const r = 0 + document.getElementById("range_maskFactor").value;
		v_maskFactor = 0.01*r;
		document.getElementById("text_maskFactor").innerHTML = " " + v_maskFactor.toFixed(2);
		changeFlag = 1;
	}

	function setMaskRatio() {
		const r = 0 + document.getElementById("range_maskRatio").value;
		v_maskRatio = 0.01*r;
		document.getElementById("text_maskRatio").innerHTML = " " + v_maskRatio.toFixed(2);
		changeFlag = 1;
	}

	/*
	function setPopDens() {
		const d = 0 + document.getElementById("range_popDens").value;
		v_popDens = 1000*d;
		document.getElementById("text_popDens").innerHTML = " " + v_popDens.toFixed();
		resetFlag = 1;
	}

	function setRemovedRatio() {
		const r = 0 + document.getElementById("range_removedRatio").value;
		v_removedRatio = 0.01*r;
		document.getElementById("text_removedRatio").innerHTML = " " + v_removedRatio.toFixed(2);
		resetFlag = 1;
	}
	*/

	function setSpeed() {
		nCalc = 1 + document.getElementById("slct_speed").selectedIndex;
	}

	function setDrawMode() {
		const st = document.getElementById("slct_timeRange");

		drawMode = document.getElementById("slct_drawMode").selectedIndex;
		st.disabled = (drawMode==2 || drawMode==3) ? false : true;
	}

	function setTimeRange() {
		timeRange = setTimeRange.range[document.getElementById("slct_timeRange").selectedIndex];
	}
	setTimeRange.range = [180,360,720,1080];

	function getData() {
		outputFlag = 1; 
	}

	function viewHome() {
		viewHomeRequested = true;
	}
	
	
	//--------------------  public  --------------------
	
	return {
		main:				main,				// main()
		
		// dom control
		reset:				reset,				// reset()
		pause:				pause,				// pause()
		step:				step,				// step()
		
		setInfectProb:		setInfectProb,		// setInfectProb()
		setSigma:			setSigma,			// setSigma()
		setGamma:			setGamma,			// setGamma()
		setMaskFactor:		setMaskFactor,		// setMaskFactor()
		setMaskRatio:		setMaskRatio,		// setMaskRatio()
		//setPopDens:			setPopDens,			// setPopDens()
		//setRemovedRatio:	setRemovedRatio,	// setRemovedRatio()
		
		setSpeed:			setSpeed,			// setSpeed()
		setDrawMode:		setDrawMode,		// setDrawMode()
		setTimeRange:		setTimeRange,		// setTimeRange()
		getData:			getData,			// getData()
		viewHome:			viewHome,			// viewHome()
	};

})(); //==============  tjs115 module end  =========================================================================


// event
const tjs = tjs115;
window.addEventListener('load', tjs.main );


//--------------------  end of javaScript

  </script>
  <style type="text/css">
    body { color:#000000; background-color:#fff8dd;}
  </style>
</head>
<body>

<p>[tjs115] mask effect - SEIR infection - Monte-Carlo simulation 2D</p>
<div style="position: relative; overflow: hidden; width: 500px; height: 480px">
  <canvas id="myCanvas" style="position: absolute; top: 0px; left: 0px"></canvas>
  <div id="textOnCanvas" 
    style="position:absolute; top:5px; left:5px; color:#888888; background-color:rgba(0, 0, 0, 0);
           font-size:0.9rem"> ... One moment, please.<br> ... setting up the studio ... </div>
</div>

<label>infection probability =</label>
<input type="range" id="range_infectiusProb" min="1" max="100" value="40" step="1" 
style="width:200px" oninput="tjs.setInfectProb()">
<label id="text_infectiusProb"> 0.040</label>
<br>

<label>sigma (incidence rate)=</label>
<input type="range" id="range_sigma" min="1" max="100" value="40" step="1" 
style="width:200px" oninput="tjs.setSigma()">
<label id="text_sigma"> 0.20 (1/ 5.0 day)</label>
<br>

<label>gamma (recovery rate)=</label>
<input type="range" id="range_gamma" min="1" max="100" value="20" step="1" 
style="width:200px" oninput="tjs.setGamma()">
<label id="text_gamma"> 0.10 (1/ 10.0 day)</label>
<br>

<label>mask factor =</label>
<input type="range" id="range_maskFactor" min="0" max="100" value="70" step="1" 
style="width:200px" oninput="tjs.setMaskFactor()">
<label id="text_maskFactor"> 0.70</label>
<br>

<label>mask ratio =</label>
<input type="range" id="range_maskRatio" min="0" max="100" value="0" step="1" 
style="width:200px" oninput="tjs.setMaskRatio()">
<label id="text_maskRatio"> 0.00</label>
<br>

<!--
<label>population density =</label>
<input type="range" id="range_popDens" min="10" max="60" value="40" step="1" 
style="width:200px" oninput="tjs.setPopDens()">
<label id="text_popDens"> 40000</label>
<br>

<label>vaccinated ratio =</label>
<input type="range" id="range_removedRatio" min="0" max="100" value="0" step="1" 
style="width:200px" oninput="tjs.setRemovedRatio()">
<label id="text_removedRatio"> 0.00</label>
<br>
-->

<label>speed =</label>
<select id="slct_speed" onChange="tjs.setSpeed()">
<option selected>1</option><option>2</option><option>3</option><option>4</option>
<option>5</option><option>6</option>
</select>
    <span style="margin-right: 20px;"></span>
<label>time range:</label>
<select id="slct_timeRange" onChange="tjs.setTimeRange()">
<option >0 - 180</option><option selected>0 - 360</option><option >0 - 720</option>
<option >0 - 1080</option>
</select>
    <span style="margin-right: 60px;"></span>
<button onClick="tjs.reset()">reset</button>
    <span style="margin-right: 20px;"></span>
<button id="pause_button" onClick="tjs.pause()">pause</button>
    <span style="margin-right: 10px;"></span>
<button id="step_button" onClick="tjs.step()">step</button>
<br>

<label>drawMode:</label>
<select id="slct_drawMode" onChange="tjs.setDrawMode()">
<option>walkers SEIR</option><option>magnify x 5</option>
<option selected>plot SEIR</option><option >log plot SEIR</option>
<option>threejs walkers</option>
</select>
    <span style="margin-right: 170px;"></span>
<button onClick="tjs.viewHome()">return to initial view</button>
<br>

<button id="getData_button" onClick="tjs.getData()">output text data</button>
<br>

<textarea id="outputText" rows="4" cols="60" disabled></textarea>
<br>

<hr width="500" align="left" color="#a0a0a0">
<div id="text_caption" ></div>
<hr width="500" align="left" color="#a0a0a0">
<a href="javascript:history.back()">back</a> | <a href="http://mike1336.web.fc2.com/index.html">top</a>
<br>
</body>
</html>

