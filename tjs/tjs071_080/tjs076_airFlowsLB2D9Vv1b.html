<!DOCTYPE html>
<html>
<head>
  <title>tjs076_airFlowsLB2D9V</title>
  <meta charset="utf-8"/>
  <script src="../lib/three.min.js"></script>
  <script src="../lib/OrbitControls.js"></script>
  <script>

'use strict';

/* =================================================================================================================
//
//  tjs076_airFlowsLB2D9V
//    Copyright(C) 2022-2023 Mitsuru Ikeuchi
//    Released under the MIT license ( https://opensource.org/licenses/MIT ) 
//
//    ver 0.0.0  2022.03.13 created, last updated on 2022.03.16
//    ver 0.0.1  2022.08.25 v1, last updated on 2023.01.08
//
//
//------------------------------------------------------------------------------------------------------------------
//
//  Lattice Boltzmann Method - 2D9V model
//
//    2D9V model - velocity distribution in lattice i,j:
//       base vectors: e[0]=[ 0, 0], e[1]=[ 1, 0], e[2]=[ 1,-1], e[3]=[ 0,-1], e[4]=[-1,-1],
//                     e[5]=[-1, 0], e[6]=[-1, 1], e[7]=[ 0, 1], e[8]=[ 1, 1]
//       velocity distribution at lattice i,j: fv[i][j][k]*e[k], k=0,1,2,...,8
//
//    procedure
//
//      (1) set lattice:
//          density: rho[i][j],
//          flow velocity: ux[i][j],uy[i][j]
//          velosity distribution: f[i][j][k] (k=0,1,2,...,8)
//
//      (2) streaming  f(r+ek*dt,t+dt) = f(r,t)
//         ftx[i][j][0] <-- ftp[i][j][0]     // e[0]=[ 0, 0]
//         ftx[i][j][1] <-- ftp[i-1][j][1]   // e[1]=[ 1, 0]
//         ftx[i][j][2] <-- ftp[i-1][j+1][2] // e[2]=[ 1,-1]
//         ftx[i][j][3] <-- ftp[i][j+1][3]   // e[3]=[ 0,-1]
//         ftx[i][j][4] <-- ftp[i+1][j+1][4] // e[4]=[-1,-1]
//         ftx[i][j][5] <-- ftp[i+1][j][5]   // e[5]=[-1, 0]
//         ftx[i][j][6] <-- ftp[i+1][j-1][6] // e[6]=[-1, 1]
//         ftx[i][j][7] <-- ftp[i][j-1][7]   // e[7]=[ 0, 1]
//         ftx[i][j][8] <-- ftp[i-1][j-1][8] // e[8]=[ 1, 1]
//            
//      (3) scattering  f(r,t+dt) = f(r,t+dt) - omega*(f(r,t+dt)-feq))
//         rho = sigma(f[i][j][k], k=0,1,2,...,8)
//         vx = sigma(e[k][0]*f[i][j][k], k=0,1,2,...,8)/rho
//         vy = sigma(e[k][1]*f[i][j][k], k=0,1,2,...,8)/rho
//         feq[k]: equilibrium velocity distribution (rho*u = sum(feq[k]*e[k],k=0,...8)
//                 feq[k] = w[k]*rho(r)*(1+3*(e[k].u)+4.5*(e[k].u)^2-1.5u^2) (D2Q9 at c=dx/dt=1)
//         f[i][j][k] = f[i][j][k] - omega*(f[i][j][k]-feq[k])
//           omega = 1/tau = 1/(3*kineticViscosity+0.5),(2D,dx=1,dt=1). tau:relaxation time
//
//         at boundary
//           wall: bounce-back ( E <--> W, N <--> S, NE <--> SW, NW <--> SE )
//           velocity boundary: set rho,ux,uy and feq
//
//      goto (2)
//
//
//------------------------------------------------------------------------------------------------------------------
*/

const airFlowsLB2D9V = (function(){ //========================  airFlowsLB2D9V Module  =============================

	const gc_NNxMax = 360;			// maximum array x-size of field
	const gc_NNyMax = 360;			// maximum array y-size of field

	var g_sysTime = 0.0;			// system time
	var g_dt = 1.0;					// time step
	var g_dx = 1.0;					// x-division
	var g_dy = 1.0;					// y-division
	var g_tpp = 0;					// present time v9[tpp][i][j], tpp = 0 or 1 
	var g_tnx = 1;					// next    time v9[tnx][i][j], tnx = 1 or 0
	var g_status = 'STABLE';		// system status (in string)

	var g_themeNum = 0;				// theme mnumber 0 - 6
	var g_themeStr = "theme";		// theme eg. "gas expansion"
	var g_NNx = 180;				// array x-size of field
	var g_NNy = 180;				// array y-size of field
	var g_drawScale = 2;			// draw scale
	var g_vxBoundary = 0.1;			// periodic condition : vx=0.1 (sound speed = 1.0) at x=0
	var g_vyBoundary = 0.0;			// periodic condition : vy=0.0 (sound speed = 1.0) at x=0

	var g_xCanvasSize = 400;		// in pixel
	var g_yCanvasSize = 400;		// in pixel

	var g_imageData = null;			// display image data pointer
	var g_xProbe = 360/2;			// probe position x
	var g_yProbe = 180/2;			// probe position y

	//              0     1     2     3     4     5     6     7    8
	var g_feq = [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]; // equilibrium velocity distribution
	var g_kind = dimInt2(gc_NNxMax,gc_NNyMax);		// kind[ix][iy] 0:free space,1:wall,2:velocity boundary
	var g_v9 = dim4(2,gc_NNxMax,gc_NNyMax,9);		// velocity distribution v9[tpp/tnx][ix][iy][0-8]
	var g_rho = dim2(gc_NNxMax,gc_NNyMax);			// density rho[ix][iy]
	var g_ux = dim2(gc_NNxMax,gc_NNyMax);			// x-component of flow velocity (sound speed = 1.0)
	var g_uy = dim2(gc_NNxMax,gc_NNyMax);			// y-component of flow velocity (sound speed = 1.0)

	var g_hue = dimInt2(3,371);
	var g_hueColor = [];

	(function() {
		var deg,x;

		for (deg=0; deg<361; deg++) {
			if (deg<60) {
				x = deg;
				g_hue[0][deg] = 255;
				g_hue[1][deg] = Math.floor(255.0*x/60.0);
				g_hue[2][deg] = 0;
			} else if (deg<120) {
				x = deg-60;
				g_hue[0][deg] = Math.floor(255.0*(60.0-x)/60.0);
				g_hue[1][deg] = 255;
				g_hue[2][deg] = 0;
			} else if (deg<180) {
				x = deg-120;
				g_hue[0][deg] = 0;
				g_hue[1][deg] = 255;
				g_hue[2][deg] = Math.floor(255.0*x/60.0);
			} else if (deg<240) {
				x = deg-180;
				g_hue[0][deg] = 0;
				g_hue[1][deg] = Math.floor(255.0*(60.0-x)/60.0);
				g_hue[2][deg] = 255;
			} else if (deg<360) {
				x = deg-240;
				g_hue[0][deg] = Math.floor(255.0*x/120.0);
				g_hue[1][deg] = 0;
				g_hue[2][deg] = Math.floor(255.0*(120.0-x)/120.0);
			} else {
				g_hue[0][deg] = 0; g_hue[1][deg] = 0; g_hue[2][deg] = 0;
			}

			g_hueColor[deg] = 'rgb('+g_hue[0][deg]+','+g_hue[1][deg]+','+g_hue[2][deg]+')';
		}
	}());

	function dim2(ni,nj) {
		var i,j, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = 0.0;
			}
		}
		return a;
	}

	function dimInt2(ni,nj) {
		var i,j, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = 0;
			}
		}
		return a;
	}

	function dim4(ni,nj,nk,nl) {
		var i,j,k,l, a=[];

		for (i=0; i<ni; i++) {
			a[i] = [];
			for (j=0; j<nj; j++) {
				a[i][j] = [];
				for (k=0; k<nk; k++) {
					a[i][j][k] = [];
					for (l=0; l<nl; l++) {
						a[i][j][k][l] = 0.0;
					}
				}
			}
		}
		return a;
	}


	//--------------------  set theme and user parameter  --------------------

	var g_themeParam = [
		// 0:themeStr            1:NNx 2:NNy 3:sc 4:nue 5:vxFlow 6:rhoMag
		["gas expansion",        180,  180,  2,   0.04, 0.000,  1.0  ],
		["gas expansion+object", 180,  180,  2,   0.06, 0.000,  1.0  ],
		["vortex",               180,  180,  2,   0.06, 0.000,  3.0  ],
		["Couette flow",         180,   90,  2,   0.20, 0.200, 10.0  ],
		["cavity flow",          120,  120,  3,   0.10, 0.200, 30.0  ],
		["wind tunnel(180x90)",  180,   90,  2,   0.02, 0.100, 30.0  ],
		["wind tunnel(120x60)",  120,   60,  3,   0.02, 0.100, 30.0  ]
	];

	var g_userParam = {
		powderON : true,
		probeON : false,
		nue : 0.06,
		vxFlow : 0.10,
		rhoMag : 1.0
	};

	function setThemeAndUserParam(theme) {
		g_themeNum = theme;
		g_themeStr = g_themeParam[theme][0];
		g_NNx = g_themeParam[theme][1];
		g_NNy = g_themeParam[theme][2];
		g_drawScale = g_themeParam[theme][3];
		g_userParam.nue = g_themeParam[theme][4];
		g_userParam.vxFlow = g_themeParam[theme][5];
		g_userParam.rhoMag = g_themeParam[theme][6];
	}


	//--------------------  set initial condition  --------------------

	function setInitialCondition( theme ) {

		g_imageData = null;
		g_status = 'STABLE';
		g_sysTime = 0.0;
		setThemeAndUserParam(theme);
		g_vxBoundary = g_userParam.vxFlow;
		setInitialLattice(theme);
		powder.setInitialPosition(); // powder
		g_xProbe = 360/2; g_yProbe = 180/2;
	}

	function setInitialLattice(theme) {
		var i,j,k,nnx=g_NNx,nny=g_NNy, rh,vx,vy,x0,y0,r;

		rh = 1.0;
		vx = 0.0;
		vy = 0.0;
		// free space
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				g_kind[i][j] = 0;
				if (theme==0 || theme==1) { // 0:gas expansion 1:gas expansion+object
					x0 = nnx/3;
					y0 = nny/3;
					rh = ((i-x0)*(i-x0)+(j-x0)*(j-x0)<30*30) ? 1.5 : 0.5;
				} else if (theme==2) { // 2:vortex
					x0 = nnx/2;
					y0 = nny/2;
					r = 0.4*nnx;
					if ( (i-x0)*(i-x0)+(j-y0)*(j-y0)<r*r) {
						vx = -0.4*(j-y0)/r;
						vy = 0.4*(i-x0)/r;
					} else {
						vx = 0.0;
						vy = 0.0;
					}
				} else if (theme==3) { // 3:Couette flow
					vx = g_userParam.vxFlow;
					vy = 0.0;
					rh = 1.0;
				} else if (theme==5 || theme==6) { // 5-6:wind tunnel
					vx = g_userParam.vxFlow;
					vy = 0.0;
					rh = 1.0;
				}
				setEquiLattice(g_v9[g_tpp][i][j], rh, vx, vy, i, j);
			}
		}
		// set boundary
		if (theme==1) { // gas expansion+object
			for (i=80; i<120; i++) {
				for (j=70; j<130; j++) {
					if ((i-100)*(i-100)/(10*10)+(j-100)*(j-100)/(20*20)<1) {
						setWall(i,j);
					}
				}
			}
		} else if (theme==3) { // 3:Couette flow
			for (i=0; i<nnx; i++) {
				setWall(i,0);
				setWall(i,nny-1);
			}
			for (j=1; j<nny-1; j++) {
				g_kind[0][j] = 2; // velocity boundary
			}
		} else if (theme==4) { // 4:cavity flow
			for (i=0; i<nnx; i++) {
				g_kind[i][0] = 2; // velocity boundary
				setWall(i,nny-1);
			}
			for (j=1; j<nny-1; j++) {
				setWall(0,j);
				setWall(nnx-1,j);
			}
		} else if (theme==5 || theme==6) { // 5-6:wind tunnel
			r = Math.floor(nny/10);
			for (j=Math.floor(nny/2)-r; j<Math.floor(nny/2)+r; j++) {
				setWall(Math.floor(nnx/5),j);
			}
			for (j=0; j<nny; j++) {
				g_kind[0][j] = 2; // velocity boundary
			}
			for (i=1; i<nnx; i++) {
				g_kind[i][0] = 2; // velocity boundary
			}
		}
	}

	function setWall(i,j) {
		g_kind[i][j] = 1; // wall
		for (var k=0; k<9; k++) {
			g_v9[g_tpp][i][j][k] = 0.0;
		}
	}


	//--------------------  time evolution  --------------------

	function timeEvolution( nCalc ) {
		var i;

		if (g_status=='STABLE') {
			for (i=0; i<nCalc; i++) {
				streaming();
				scattering(g_userParam.nue); //nue: kinetic viscosity
				if (g_userParam.powderON) powder.move(); // powder
				if (g_status != 'STABLE') break;
				g_sysTime += g_dt;
				g_tpp = g_tnx;
				g_tnx = (g_tnx+1)%2;
			}
		}
		return g_status;
	}

	//--- (2) streaming

	function streaming() {
		var i,j,ip,im,jp,jm,nnx=g_NNx,nny=g_NNy, fij;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				ip = (i+1)%nnx; 
				im = (i-1+nnx)%nnx;
				jp = (j+1)%nny;
				jm = (j-1+nny)%nny;
				fij = g_v9[g_tnx][i][j];
				fij[0] = g_v9[g_tpp][i][j][0];   // e[0]=[ 0, 0]
				fij[1] = g_v9[g_tpp][im][j][1];  // e[1]=[ 1, 0]
				fij[2] = g_v9[g_tpp][im][jp][2]; // e[2]=[ 1,-1]
				fij[3] = g_v9[g_tpp][i][jp][3];  // e[3]=[ 0,-1]
				fij[4] = g_v9[g_tpp][ip][jp][4]; // e[4]=[-1,-1]
				fij[5] = g_v9[g_tpp][ip][j][5];  // e[5]=[-1, 0]
				fij[6] = g_v9[g_tpp][ip][jm][6]; // e[6]=[-1, 1]
				fij[7] = g_v9[g_tpp][i][jm][7];  // e[7]=[ 0, 1]
				fij[8] = g_v9[g_tpp][im][jm][8]; // e[8]=[ 1, 1]
			}
		}
	}

	//--- (3) scattering

	function scattering(kineticViscosity) {
		var i,j,k,nnx=g_NNx,nny=g_NNy, omega,fij,rh,vx,vy,m;

		omega = 1.0/(3.0*kineticViscosity+0.5); // omega = 1/tau; tau: relaxation time
		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				fij = g_v9[g_tnx][i][j];
				if (g_kind[i][j]==0) { // free space
					rh = fij[0]+fij[1]+fij[2]+fij[3]+fij[4]+fij[5]+fij[6]+fij[7]+fij[8]; // rho;
					if (rh>=0) {
						vx = (fij[1]+fij[2]-fij[4]-fij[5]-fij[6]+fij[8])/rh; // flow vx;
						vy = (-fij[2]-fij[3]-fij[4]+fij[6]+fij[7]+fij[8])/rh; // flow vy;
						setEquiLattice(g_feq, rh, vx, vy, i, j); // set equilibrium feq at rho,vx,vy
						for (k=0; k<9; k++) {
							fij[k] -= omega*(fij[k]-g_feq[k]);
						}
					} else {
						g_status = "UNSTABLE at i="+i+",j="+j+",g_rho="+rh.toFixed(3)+"<br>"+
									"press reset or another theme";
					}
				} else if (g_kind[i][j]==1) { // wall: bounce-back boundary
					fij[0] = 0.0;
					m = fij[1]; fij[1] = fij[5]; fij[5] = m; // e[1]=[ 1, 0], e[5]=[-1, 0]
					m = fij[2]; fij[2] = fij[6]; fij[6] = m; // e[2]=[ 1,-1], e[6]=[-1, 1]
					m = fij[3]; fij[3] = fij[7]; fij[7] = m; // e[3]=[ 0,-1], e[7]=[ 0, 1]
					m = fij[4]; fij[4] = fij[8]; fij[8] = m; // e[4]=[-1,-1], e[8]=[ 1, 1]
				} else if (g_kind[i][j]==2) { // velocity boundary
					setEquiLattice(fij, 1.0, g_vxBoundary, g_vyBoundary, i, j);
				}
			}
		}
	}

	function setEquiLattice(veq, rh, vx, vy, i, j) {
		g_rho[i][j] = rh;
		g_ux[i][j] = vx;
		g_uy[i][j] = vy;
		setEquilibriumV9(veq, rh, vx, vy);
	}

	function setEquilibriumV9(veq, rh, vx, vy) {
		var c0,c1v,c2v,c3v,c4v,c5v,c6v,c7v,c8v;
		var w0rh = rh*4.0/9.0;
		var w1rh = rh/9.0;
		var w2rh = rh/36.0;

		c0 = 1.0 - 1.5*(vx*vx+vy*vy);
		c1v = vx;     // e[1]=[ 1, 0], (e.u) = (1,0).(vx,vy) = vx
		c2v = vx-vy;  // e[2]=[ 1,-1]
		c3v = -vy;    // e[3]=[ 0,-1]
		c4v = -vx-vy; // e[4]=[-1,-1]
		c5v = -vx;    // e[5]=[-1, 0]
		c6v = -vx+vy; // e[6]=[-1, 1]
		c7v = vy;     // e[7]=[ 0, 1]
		c8v = vx+vy;  // e[8]=[ 1, 1]
		// feq[k] = w[k]*rho(r)*(1+3*(e[k].u)+4.5*(e[k].u)^2-1.5u^2)
		veq[0] = w0rh*c0;
		veq[1] = w1rh*(c0 + 3.0*c1v + 4.5*c1v*c1v);
		veq[2] = w2rh*(c0 + 3.0*c2v + 4.5*c2v*c2v);
		veq[3] = w1rh*(c0 + 3.0*c3v + 4.5*c3v*c3v);
		veq[4] = w2rh*(c0 + 3.0*c4v + 4.5*c4v*c4v);
		veq[5] = w1rh*(c0 + 3.0*c5v + 4.5*c5v*c5v);
		veq[6] = w2rh*(c0 + 3.0*c6v + 4.5*c6v*c6v);
		veq[7] = w1rh*(c0 + 3.0*c7v + 4.5*c7v*c7v);
		veq[8] = w2rh*(c0 + 3.0*c8v + 4.5*c8v*c8v);
	}

	//--- utility

	function vorticity(i, j) {
		if (i==0 || i==g_NNx-1 || j==0 || j==g_NNy-1) return 0.0;
		return (g_uy[i+1][j]-g_uy[i-1][j])/(2*g_dx)-(g_ux[i][j+1]-g_ux[i][j-1])/(2*g_dy);
	}

	function speed(i,j) {
		var uxij= g_ux[i][j], uyij= g_uy[i][j];
		return Math.sqrt( uxij*uxij+uyij*uyij );
	}

	function totalRho() {
		var i,j,nnx=g_NNx,nny=g_NNy, s=0.0;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				if (g_kind[i][j]==0) s += g_rho[i][j];
			}
		}
		return s;
	}

	function meanRho() {
		var i,j,nnx=g_NNx,nny=g_NNy, n=0, s=0.0;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				if (g_kind[i][j]==0) {
					n++;
					s += g_rho[i][j];
				}
			}
		}
		return s/n;
	}
	

	//--------------------  draw  --------------------

	function draw(ctx, drawMode, dispAdd ) {
		var px=20,py=20, sc=g_drawScale;
		var iProbe,jProbe;

		if ( g_imageData==null ) {
			g_imageData = ctx.getImageData(20, 20, 360, 360);
			setImageData();
		}

		drawField(ctx, drawMode,px,py,sc); // drawMode  0:wall 1:density 2:vorticity 3:flow speed

		if (dispAdd==1) { // dispAdd  0:none 1:flow vx,vy 2:powder
			drawFlow(ctx, px,py,sc);
		} else if (dispAdd==2) {
			powder.draw(ctx, px,py,sc); // powder
		}

		ctx.fillStyle = "rgb(0, 0, 0)";
		//ctx.fillText("drawMode="+drawMode+",  dispAdd=="+dispAdd, 10, g_yCanvasSize-2);
		ctx.fillText("time="+g_sysTime+",  nue="+g_userParam.nue, 10, g_yCanvasSize-2);
		ctx.fillText("(rho-1)x"+g_userParam.rhoMag, 300, g_yCanvasSize-2);
		ctx.fillStyle = "rgb(0, 0, 0)";
		ctx.fillText("(rho-1)x"+g_userParam.rhoMag, 300, g_yCanvasSize-2);
		/*
		if (prbON) {
			ctx.font = "11px 'sans-serif'";
			ctx.fillStyle = "rgb(180, 0, 180)";
			ctx.fillRect(g_xProbe+px-1,g_yProbe+py-1,3,3);
			iProbe=Math.floor(g_xProbe/sc);
			jProbe=Math.floor(g_yProbe/sc);
			ctx.fillText("probe("+iProbe+","+jProbe+"), rho="+g_rho[iProbe][jProbe].toFixed(4)+
							", vx="+g_ux[iProbe][jProbe].toFixed(4)+", vy="+g_uy[iProbe][jProbe].toFixed(4)+
							"   (click to move)", 20, 18);
			ctx.font = "16px 'sans-serif'";
		}
		*/
	}

	function setImageData() {
		var i,j,idx,xSize=360,ySize=360, data,r,g,b;

		data = g_imageData.data;
		for (j=0; j<ySize; j++) {
			for (i = 0; i<xSize; i++) {
				idx = (j*xSize+i)*4;
				data[idx] = 0xbb;
				data[++idx] = 0xbb;
				data[++idx] = 0xbb;
				data[++idx] = 0xff;
			}
		}
	}

	function drawField(ctx, FieldMode,px,py,sc) {
		var i,j,nnx=g_NNx,nny=g_NNy,colIndex, deg,aSize=sc;

		for (i=0; i<nnx; i++) {
			for (j=0; j<nny; j++) {
				if (FieldMode==0) { // wall
					deg = -60;
				} else if (FieldMode==1) { // rho[i][j]
					deg = Math.floor(120*g_userParam.rhoMag*(g_rho[i][j]-1.0));
				} else if (FieldMode==2) { // vorticity(i,j)
					deg = Math.floor(5000*vorticity(i,j));
				} else if (FieldMode==3) { // speed(i,j)
					deg = Math.floor(1200*(Math.sqrt(g_ux[i][j]*g_ux[i][j]+g_uy[i][j]*g_uy[i][j])-0.1));
				}
				if (deg<-150) deg = -150;
				if (deg>150) deg = 150;
				colIndex = ((120-deg)+360)%360;
				// wall
				if (g_kind[i][j]==1) colIndex = 360; // color black

				setSquare(i*aSize,(nny-j)*aSize,aSize,colIndex);
			}
		}
		ctx.putImageData(g_imageData, px, py);
	}

	function setSquare(ix,iy,aSize,colIndex) {
		var pi,pj,idx, xSize=360;

		for (pj=iy; pj<iy+aSize; pj++) {
			for (pi=ix; pi<ix+aSize; pi++) {
				idx = (pj*xSize+pi)*4;
				g_imageData.data[idx] = g_hue[0][colIndex];
				g_imageData.data[idx+1] = g_hue[1][colIndex];
				g_imageData.data[idx+2] = g_hue[2][colIndex];
			}
		}
	}

	function setSquare2Canvas(ctx, ix,iy,aSize,colIndex) {
		ctx.fillStyle = g_hueColor[colIndex];
		ctx.fillRect(ix,iy,aSize,aSize);
	}

	function drawFlow(ctx, px,py,sc) {
		var i,j,nnx=g_NNx,nny=g_NNy,mag=100, vx,vy;

		for (i=2; i<nnx; i+=5) {
			for (j=2; j<nny; j+=5) {
				ctx.strokeStyle = (g_ux[i][j]>0) ? "#4444ff" : "#ff4444";
				ctx.beginPath();
				ctx.lineTo(px+i*sc, py+(nny-j)*sc);
				ctx.lineTo(px+i*sc+g_ux[i][j]*mag, py+(nny-j)*sc-g_uy[i][j]*mag);
				ctx.stroke();
			}
		}
	}


	//--------------------  powder (LB2D)  --------------------

	// external var g_NNx,g_NNy,g_dx,g_dy,g_dt,g_ux[][],g_uy[][],g_kind[][]

	var powder = {};   // namespace of powder module
	powder.n = 300;    // n: number of powder
	powder.x = [];     // x-position of i-th powder
	powder.y = [];     // y-position of i-th powder

	powder.setInitialPosition = function() {
		var i, nn=powder.n, px=powder.x, py=powder.y;

		for (i=0; i<nn; i++) {
			px[i] = (g_NNx-2)*Math.random()+1;
			py[i] = (g_NNy-2)*Math.random()+1;
		}
	};

	powder.move = function() {
		var i,ix,iy,nnx=g_NNx,nny=g_NNy,nn=powder.n, ta=g_dt*(1.0/g_dx), px=powder.x, py=powder.y;

		for (i=0; i<nn; i++) {
			ix = Math.floor(px[i]);
			iy = Math.floor(py[i]);
			px[i] += g_ux[ix][iy]*ta;
			py[i] += g_uy[ix][iy]*ta;
			if (px[i]>=nnx) px[i] -= nnx;
			if (px[i]<0) px[i] += nnx;
			if (py[i]>=nny) py[i] -= nny;
			if (py[i]<0) py[i] += nny;
			if (g_kind[ix][iy]==1) {
				px[i] = (nny-2)*Math.random()+1;
				py[i] = (nny-2)*Math.random()+1;
			} else if (g_kind[ix][iy]==2) {
				if ( Math.random()<0.001 ) {
					px[i] = (nny-2)*Math.random()+1;
					py[i] = (nny-2)*Math.random()+1;
				}
			}
		}
	};

	powder.draw = function(ctx, xp,yp,sc) {
		var i, nn=powder.n, px=powder.x, py=powder.y, yMax=g_NNy*g_dx;

		ctx.fillStyle = "#ff80ff";
		for (i=0; i<nn; i++) {
			ctx.fillRect(xp+px[i]*sc,yp+(yMax-py[i])*sc,2,2);
		}
	};


	//--------------------  public  --------------------

	return {
		init:			setInitialCondition,	// setInitialCondition( theme )
		evolve:			timeEvolution,			// timeEvolution( nCalc )
		draw:			draw,					// draw( ctx, drawMode, dispAdd, probeON )

		setPowderON:	function( sw ) { g_userParam.powderON = sw; },
		setProbeON:		function( sw ) { g_userParam.probeON = sw; },

		getSysParam:	function() { return [ g_NNx, g_NNy, g_dx, g_dt, powder.n ]; },
		getUserParam:	function() { return [ g_userParam.nue, g_userParam.vxFlow, g_userParam.rhoMag ]; },
		getNow:			function() { return [ g_sysTime, g_status, g_themeStr, meanRho() ]; },
		getCellKind:	function(i,j) { return g_kind[i][j]; },
		getFlow:		function(i,j) { return [ g_ux[i][j], g_uy[i][j] ]; },
		getDensity:		function(i,j) { return g_rho[i][j]; },	
		getVorticity:	vorticity,				// vorticity(i,j)
		getSpeed:		speed,					// speed(i,j)
		getPowderPos:	function(ipow) { return [ powder.x[ipow], powder.y[ipow] ]; },
  };

})(); //==============  airFlowsLB2D9V end  ========================================================================


const tjs076 = (function(){ //========================  tjs Module  ================================================

	// theModule.init( v_theme )
	// theModule.evolve( v_nCalc )
	// theModule.draw( ctx, drawMode, dispAdd, probeON )
	/*
		// 0:themeStr            1:NNx 2:NNy 3:sc 4:nue 5:vxFlow 6:rhoMag
		["gas expansion",        180,  180,  2,   0.04, 0.000,  1.0  ],
		["gas expansion+object", 180,  180,  2,   0.06, 0.000,  1.0  ],
		["vortex",               180,  180,  2,   0.06, 0.000,  3.0  ],
		["Couette flow",         180,   90,  2,   0.20, 0.200, 10.0  ],
		["cavity flow",          120,  120,  3,   0.10, 0.200, 30.0  ],
		["wind tunnel(180x90)",  180,   90,  2,   0.02, 0.100, 30.0  ],
		["wind tunnel(120x60)",  120,   60,  3,   0.02, 0.100, 30.0  ]
	*/
	
	const theModule = airFlowsLB2D9V;
	let v_theme = 5;
	let v_nCalc = 4;
	
	let p_nx, p_ny, p_dx, p_dt, p_nPowder; // <-- theModule.getSysParam()
	let p_nue, p_vxFlow, p_rhoMag; // <-- theModule.getUserParam()
	
	let resetFlag = 0;
	let pauseFlag = 0;
	let stepFlag = 0;
	let dispMode = 1;
	let dispModeChanged = false;
	let viewHomeRequested = true;
	let legendFlag = true;
	let count = 0;
	
	// sizes in the threejs world
	const xBoxSize = 600;
	const zBoxSize = 200;
	const x0 = xBoxSize/2;
	const z0 = zBoxSize/2;
	let hh, yBoxSize, y0;
	
	// threejs world object
	let agrid;
	let vfield;
	let powder;
	let line_box;
	let wall;
	let cnvsprite;
	
	// three.js , OrbitControls.js
	const width = 500;
	const height = 480;
	const r_camera = 1250;
	let renderer;
	let scene;
	let camera;
	let controls;
	

	// --------------------  main
	
	function main() {
		// constract renderer
		renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#myCanvas'), });
		renderer.setSize(width, height);
		
		// camera
		camera = new THREE.PerspectiveCamera(30, width / height, 1, 5000);
		camera.position.set(0, -0.4*r_camera, 0.9*r_camera);
		controls = new THREE.OrbitControls(camera,renderer.domElement);
		
		initDom();
		
		constructScene();
		animate();
	}

	function constructScene() {
		
		// init MAC2D
		theModule.init( v_theme );
		[ p_nx, p_ny, p_dx, p_dt, p_nPowder ] = theModule.getSysParam();
		[ p_nue, p_vxFlow, p_rhoMag ] = theModule.getUserParam();
		hh = xBoxSize/p_nx;
		yBoxSize = hh*p_ny;
		y0 = yBoxSize/2;

		// scene
		scene = new THREE.Scene();
 
		// light - DirectionalLight
		const directionalLight = new THREE.DirectionalLight(0xffffff,0.5);
		directionalLight.position.set(1, 1, 1);
		scene.add(directionalLight);
		// light - AmbientLight
		const light = new THREE.AmbientLight(0xffffff, 1.0);
		scene.add(light);
		
		
		// grid
		// agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
		agrid = m3js_grid2D( p_nx, p_ny, xBoxSize );
		scene.add( agrid );
		
		// flow vector
		// vfield = m3js_vField2D( p_nx, p_ny, xBoxSize [, colorMode] ); // colorMode  0:direction color, 1:blue|red
		vfield = m3js_vField2D( p_nx, p_ny, xBoxSize, 0 );
		scene.add( vfield );
		
		// powder
		// powder = m3js_powder2D( p_nPowder, p_nx, p_ny, xBoxSize [, powderColor] )
		powder = m3js_powder2D( p_nPowder, p_nx, p_ny, xBoxSize );
		powder.setRFactor( 0.8 );
		scene.add( powder );
		
		
		// line box
		{
			const geometry = new THREE.BoxGeometry( xBoxSize, yBoxSize, zBoxSize );
			const edges = new THREE.EdgesGeometry( geometry );
			line_box = new THREE.LineSegments( edges, new THREE.LineBasicMaterial({ color: 0x666644 }) );
			scene.add( line_box );
		}
		
		// wallCube
		{
			wall = new THREE.Group();
			for (let i=0; i<p_nx; i++) {
				for (let j=0; j<p_ny; j++) {
					if (theModule.getCellKind(i,j)==1) {
						const geometry = new THREE.BoxGeometry(hh, hh, zBoxSize);
						const material = new THREE.MeshStandardMaterial({ 
							color: 0xaaaaaa, opacity: 0.5, transparent: true});
						const cube = new THREE.Mesh( geometry, material );
						cube.position.set(hh*i-x0, hh*j-y0, 0);
						wall.add( cube );
					}
				}
			}
			wall.visible = true;
			scene.add( wall );
		}
		
		// canvas sprite
		// cnvsprite = m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight )
		cnvsprite = m3js_canvasSprite( 600, 600, 400 );
		cnvsprite.position.set(0,0,0);
		scene.add( cnvsprite );
			
	}

	// loop animation
	function animate() {
		
		// select theme
		if (resetFlag==1) {
			resetFlag = 0;
			constructScene();
			dispModeChanged = true;
			count = 0;
		}

		//  switch visible objects
		if (dispModeChanged) {
			dispModeChanged = false;
			
			line_box.visible = ( dispMode<=4 ) ? true : false;
			wall.visible =  ( dispMode<=4 ) ? true : false;
			
			powder.visible = false;
			agrid.visible = false;
			vfield.visible = false;
			cnvsprite.visible = false;
		}
		
		// view home
		if ( viewHomeRequested ) {
			camera.position.set(0, -0.6*r_camera, 0.8*r_camera);
			viewHomeRequested = false;
		}
		
		// LB2D update
		if (pauseFlag==0) {
			theModule.evolve( v_nCalc );
		} else if ( pauseFlag==1 && stepFlag==1 ) {
			stepFlag = 0;
			theModule.evolve( 1 );
		}
		
		
		// powder update
		if ( dispMode==1 || dispMode==3 ) {
			const rmag = 40.0*p_rhoMag;
			// powder.update( x_y_zPos_Func )
			powder.update( 
				function(i) { //  x_y_zPos_Func(i) --> [ x, y, zPos ]
					let x, y, zPos;
					[ x, y ] = theModule.getPowderPos(i);
					const ix = Math.round(x)%p_nx;
					const iy = Math.round(y)%p_ny;
					zPos = rmag*(theModule.getDensity(ix,iy)-1.0);
					return [ x, y, zPos ];
				} 
			);

		}
		
		// grid density update
		if ( dispMode==0 || dispMode==1 ) {
			const rmag = 40.0*p_rhoMag;
			// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
			agrid.update( 
				function(i,j) { return [ rmag*(theModule.getDensity(i,j)-1.0),   ] } // hue: default
			);
		}
		
		// grid vorticity update
		if ( dispMode==2 || dispMode==3 ) {
			const rmag = 40.0*p_rhoMag;
			// agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
			agrid.update( 
				function(i,j) { 
					const z = rmag*(theModule.getDensity(i,j)-1.0);
					const hue = Math.floor(36120.0 - 5000.0*theModule.getVorticity(i,j)) % 360;
					return [ z, hue ];
				}
			);
		}
		
		// flow vector field update
		if ( dispMode==4 ) {
			const fmag = 100.0;
			const rmag = 40.0*p_rhoMag;
			// vfield.update( vx_vy_z_col_func [,step] ); // vx_vy_z_col_func: (i,j) --> [vx, vy, z, [col] ]
			vfield.update(
				function(i,j) { // vx_vy_z_col_func: (i,j) --> [vx, vy, z, [col] ]
					let vx, vy;
					[ vx, vy ] = theModule.getFlow(i,j);
					const z = rmag*(theModule.getDensity(i,j)-1.0);
					return [ fmag*vx, fmag*vy, z,  ];  // col: default
				},
				2 // step
			);
		}
		
		// update sprite
		if ( dispMode>=5 ) {
			// cnvsprite.update( drawFunc )
			cnvsprite.update( 
				function( sprite ) { // drawFunc(sprite)
					const ctx = sprite.ctx;
					const canvasWidth = sprite.canvas.width;
					const canvasHeight = sprite.canvas.height;
					
					// clear canvas
					ctx.fillStyle = "#bbbbbb";
					ctx.fillRect( 0,0, canvasWidth, canvasHeight);
					
					const drawMode = (dispMode - 5) % 4;
					const dispAdd = ( (dispMode - 5)<4 ) ? 1 : 2;
					const prbON = false;
					theModule.draw(ctx, drawMode, dispAdd );
				}
			);
		}
		
		
		// output to innerHTML
		if (count % 10 == 0) {
			const xMax = p_nx*p_dx, yMax = p_ny*p_dx;
			let time, status, themeStr, meanDens;
			[ time, status, themeStr, meanDens ] = theModule.getNow();
			let msg = "time = "+time.toFixed(1) + ", the system is " + status+".<br>"
						+ "nue(kinetic viscosity) ="+p_nue
			if ( Math.abs(p_vxFlow) > 1.0e-6 ) msg += ", v/c="+p_vxFlow+"(c=sound speed)";
			document.getElementById("text_caption").innerHTML = msg;
			
			if ( legendFlag && dispMode<=4 ) {
				let msg1 = "periodic box = "+xMax+" x "+yMax+", system is "
							+ "<span style='color:#ffff00'>"+status+"</span><br>";
				if ( dispMode==2 || dispMode==3 ) {
					msg1 += "vorticity: (<0)blue clockwise, (>0)red counterclockwise rotation <br>"
				}
				if ( status != 'STABLE' ) {
					msg1 += ("<span style='color:#ff4444'>"
							+ "please select lower Re/L and press [reset] button </span><br>");
				}
				document.getElementById('textOnCanvas').innerHTML = msg1;
			} else {
				document.getElementById('textOnCanvas').innerHTML = "";
			}
		}
		
		
		count += 1;
		controls.update();
		renderer.render(scene, camera);
		requestAnimationFrame(animate);
	}
	
	
	
	// -----------------------  m3js_powder2D function  ---------------------------
	//
	//    ver 0.0.0  2022.06.28 created, last updated on 2022.12.25
	//
	//  external
	//     theModule.getPowderPos(ipow) // (ipow) --> [ x[ipow], y[ipow] ], ( position in realField )
	//        ipow: 0, 1, ..., p_nPowder
	//
	//  powder = m3js_powder2D( p_nPowder, p_nx, p_ny, xBoxSize [, powderColor] );
	//     p_nPowder: number of powders
	//     p_nx: number of x-direction lines, p_ny:number of y-direction lines
	//     xBoxSize: threejs world x-box size
	//     powderColor: color of the powder (default: 0x0xaa44aa )
	//  scene.add( powder );
	// 
	//  powder.update( x_y_zPos_Func )
	//     x_y_zPos_Func: function(ipowder) { ...; return [ xi, yi, zPos ]; }
	//       xi, yi : i-th powder position (xi,yi) in the field
	//       zPos : z-posion in the threejs world box
	//
	//  powder.visible = true | false;
	//
	//  powder.setRFactor( rfac );
	//     rfac: 0.0 ... 1.0  radius of powder = rfac*hh/2
	//
	
	const m3js_powder2D = function( p_nPowder, p_nx, p_ny, xBoxSize, powderColor ) {
		const icosaArray = [];
		const icosas = new THREE.Group();
		const nn = p_nPowder
		const nx = p_nx;
		const ny = p_ny;
		const hh = xBoxSize/nx;
		const x0 = xBoxSize/2;
		const y0 = hh*ny/2;
		const pColor = ( powderColor==undefined ) ? 0xaa44aa : powderColor;
		let rFactor = 1.0;
		
		const geometry = new THREE.IcosahedronGeometry( rFactor*hh/2.0, 1 );
		for ( let i=0; i<nn; i++ ) {
			const material = new THREE.MeshBasicMaterial({ color: pColor });
			const icosa = new THREE.Mesh( geometry, material );
			icosa.visible = false;
			icosaArray[i] = icosa;
			icosas.add( icosaArray[i] );
		}
		icosas.update = icosas_update; // icosas_update( xyPosFunc, zFunc )
		icosas.setRFactor = function( rfac ) { rFactor = rfac; };
		return icosas;
		
		function icosas_update( x_y_zPos_Func ) {
			const mag = rFactor;
			for ( let i=0; i<nn; i++ ) { 
				let x, y, zPos;
				[ x, y, zPos ] = x_y_zPos_Func(i);
				const icosa = icosaArray[i];
				icosa.position.set( x*hh-x0, y*hh-y0, zPos+0.3*hh );
				icosa.scale.set(mag,mag,mag);
				icosa.visible = true;
			}
			icosas.visible = true;
		}
	};
	
	// -----------------------  m3js_powder2D function end
	
	
	// -----------------------  m3js_grid2D function  -----------------------------------------
	//
	//    ver 0.0.0  2022.10.08 created, last updated on 2022.12.20
	//
	//  agrid = m3js_grid2D( p_nx, p_ny, xBoxSize, [zBoxSize], [mode] );
	//      p_nx: number of x-direction lines, p_ny: number of y-direction lines
	//      xBoxSize: x-box size in the threejs-world
	//		[zBoxSize]: z-box size in the threejs-world
	//      [mode]: if mode=='xLineOnly' -->  grid change to x-lines only
	//            if mode=='yLineOnly' -->  grid change to y-lines only
	//            else or undefined --> grid x-lines and y-lines
	//
	//  scene.add( agrid );
	//
	//  agrid.setPallet( pallet, color );
	//      pallet: pallet number 372 ... 399, (371:inner pallet)
	//      color: col = new THREE.Color( color )
	//
	//  agrid.update( z_hue_Func ); // z_hue_func: (i,j) --> [ z, [hue] ]
	//      z_hue_func(i,j) { ... return [ z, [hue] ]; }
	//          z: threejs world z-position at grid point (i,j)
	//          hue: 0...359 huedeg, 360(black) ...gray...370(white) 371(inner pallet) 372...399 free
	//              or string shch as 'red', '#ff0000', 'rgb(255,0,0)', 'hsl(0,100%,50%)'
	//
	// agrid.visible = false;
	//
	
	const m3js_grid2D = function( p_nx, p_ny, xBoxSize, zBoxSize, mode ) {
		const hueArray = []; // red:hue[deg][0]  green:hue[deg][1]  blue:hue[deg][2]
		const gridArray = [];
		const nx = p_nx;
		const ny = p_ny
		const hh = xBoxSize/nx;
		const x0 = xBoxSize/2.0;
		const y0 = hh*ny/2.0;
		const z0 = ( zBoxSize==undefined ) ? y0 : zBoxSize/2.0;
		const xLineOnly = ( mode==undefined || mode!='xLineOnly' ) ? false : true;
		const yLineOnly = ( mode==undefined || mode!='yLineOnly' ) ? false : true;
		const agrid = new THREE.Group();
		
		if ( hueArray.length<1 ) init_hueArray();
		
		if ( ! yLineOnly ) {
			for (let j=0; j<ny; j++) {
 				const geometry = new THREE.BufferGeometry();
 				const material = new THREE.LineBasicMaterial( { vertexColors: true } );
				const positions = new Float32Array( nx * 3 );
				const colors = new Float32Array( nx * 3 );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setDrawRange( 0, nx );
    			const line = new THREE.Line(geometry,material);
    			gridArray[j] = line;
    			agrid.add( gridArray[j] );
			}
		}
		if ( ! xLineOnly ) {
			for (let i=0; i<nx; i++) {
				const geometry = new THREE.BufferGeometry();
 				const material = new THREE.LineBasicMaterial( { vertexColors: true } );
				const positions = new Float32Array( ny * 3 );
				const colors = new Float32Array( ny * 3 );
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.setDrawRange( 0, ny );
    			const line = new THREE.Line(geometry,material);
    			gridArray[ny+i] = line;
    			agrid.add( gridArray[ny+i] );
    		}
    	}
    	
    	agrid.setPallet = setPallet; // setPallet( pallet, color )
		agrid.update = gridUpdate; // gridUpdate( fieldFunc, [hueFunc|huedeg|hueStr] )
		agrid.visible = false;
		
		return agrid;


		// private functions
		
		function gridUpdate( z_hue_Func ) {
			if ( ! yLineOnly ) {
				for (let j=0; j<ny; j++) {
					const line = gridArray[j];
					const positions = line.geometry.attributes.position.array;
					const colors = line.geometry.attributes.color.array;
					for (let i= 0; i<nx; i++) {
						let z, hue, r=0.99, g=0.99, b=0.99;
						[ z, hue ] = z_hue_Func(i,j);
						positions[i*3]   = hh*i - x0;
						positions[i*3+1] = hh*j - y0;
						positions[i*3+2] = z;
						
						if ( hue==undefined ) hue = Math.floor(36180.0 - 180.0*(z/z0)) % 360;
						if ( typeof(hue)=='number' ) {
							const deg = Math.floor(hue);
							r = hueArray[deg][0];
							g = hueArray[deg][1];
							b = hueArray[deg][2];
						} else if ( typeof(hue)=='string' ) {
							const col = new THREE.Color( hue );
							r = col.r; g = col.g; b = col.b;
						}
						colors[i*3]   = r;
						colors[i*3+1] = g;
						colors[i*3+2] = b;
					}
					line.geometry.attributes.position.needsUpdate = true;
					line.geometry.attributes.color.needsUpdate = true;
				}
			}
			if ( ! xLineOnly ) {
				for (let i=0; i<nx; i++) {
					const line = gridArray[ny+i];
					const positions = line.geometry.attributes.position.array;
					const colors = line.geometry.attributes.color.array;
					for (let j= 0; j<ny; j++) {
						let z, hue, r=0.99, g=0.99, b=0.99;
						[ z, hue ] = z_hue_Func(i,j);
						positions[j*3]   = hh*i - x0;
						positions[j*3+1] = hh*j - y0;
						positions[j*3+2] = z;
						
						if ( hue==undefined ) hue = Math.floor(36180.0 - 180.0*(z/z0)) % 360;
						if ( typeof(hue)=='number' ) {
							const deg = Math.floor(hue);
							r = hueArray[deg][0];
							g = hueArray[deg][1];
							b = hueArray[deg][2];
						} else if ( typeof(hue)=='string' ) {
							const col = new THREE.Color( hue );
							r = col.r; g = col.g; b = col.b;
						}
						colors[j*3]   = r;
            			colors[j*3+1] = g;
            			colors[j*3+2] = b;
    				}
					line.geometry.attributes.position.needsUpdate = true;
					line.geometry.attributes.color.needsUpdate = true;
				}
			}
			agrid.visible = true;
		}
		
		function setPallet( pallet, color ) {
			const deg = Math.floor(pallet);
			const col = new THREE.Color( color );
			hueArray[deg][0] = col.r;
			hueArray[deg][1] = col.g;
			hueArray[deg][2] = col.b;
		}
		
		function init_hueArray() {
			// deg= 0...359 hue color, 360: black ... gray ...  370:white,
			// 371: inner use, 372...399 as pallete
			for (let deg=0; deg<360; deg++) {
				hueArray[deg] = [];
				const col = new THREE.Color( 'hsl('+deg+',100%,50%)');
				hueArray[deg][0] = col.r;
				hueArray[deg][1] = col.g;
				hueArray[deg][2] = col.b;
			}
			for (let deg=360; deg<400; deg++) {
				hueArray[deg] = [];
				const x = (deg<371) ? (deg-360)*0.1 : 0.0;
				hueArray[deg][0] = x;
				hueArray[deg][1] = x;
				hueArray[deg][2] = x;
			}
		}
		
	};
	
	// -----------------------  m3js_grid2D function end
	
	
	// -----------------------  m3js_vField2D function  ---------------------------
	//
	//    ver 0.0.0  2022.02.04 created, last updated on 2022.12.20
	//
	//  vfield = m3js_vField2D( p_nx, p_ny, xBoxSize [, colorMode] ); // colorMode  0:direction color, 1:blue|red
	//     nx: number of x-direction division, ny:number of y-direction division
	//     xBoxSize: x-box size in threejs world
	//  scene.add( vfield );
	//
	//  vfield.update( vx_vy_z_col_func [,step] ); // vx_vy_z_col_func: (i,j) --> [vx, vy, z, [col] ]
	//     vx_vy_z_col_func: function(i,j) { return [vx, vy, z, [col] ]; }
	//     [step]: step of for-loop, 1:default, else 2 or 3 or 4 ... 
	//
	//  vfield.visible = false;
	//
	
	function m3js_vField2D( p_nx, p_ny, xBoxSize, colorMode ) {
		const nx = p_nx;
		const ny = p_ny;
		const hh = xBoxSize/p_nx;
		const x0 = xBoxSize/2.0;
		const y0 = hh*p_ny/2.0;
		const vectorArray = [];
		const lines = new THREE.Group();
		const cMode = ( colorMode==undefined ) ? 1 : colorMode;
		
		for (let i=0; i<nx; i++) {
			vectorArray[i] = [];
			for (let j=0; j<ny; j++) {
				const geometry = new THREE.BufferGeometry();
				const positions = new Float32Array( 2 * 3 ); // MAX_POINTS = 2,  3 vertices per point
				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setDrawRange( 0, 2 );
				const material = new THREE.LineBasicMaterial( { color: 0x888888 } );
				const line = new THREE.Line( geometry, material );
				line.visible = false;
				vectorArray[i][j] = line;
    			lines.add( vectorArray[i][j] );
			}
		}
		
		lines.update = linesUpdate;
		
		return lines;
		
		
		function linesUpdate( vx_vy_z_col_func, step ) {
			const inc = ( step == undefined ) ? 1 : step;
			for (let i=0; i<nx; i+=inc) {
				for (let j=1; j<ny; j+=inc) {
					const line = vectorArray[i][j];
					const positions = line.geometry.attributes.position.array;
					const vec = vx_vy_z_col_func(i,j);
					if ( !Array.isArray(vec) ) {
						line.visible = false;
						continue;
					}
					let vx, vy, z, col, h=0;
					[ vx, vy, z, col ] = vec;
					if ( col==undefined ) {
						if ( cMode==0 ) {
							h = Math.floor((Math.atan2(vy,vx))*180.0/Math.PI+180.0);

						} else if ( cMode==1 ) {
							h = (vx>=0.0) ? 240 : 0;
						}
						col = `hsl(${h},100%,50%)`;
					}
					let x = hh*i-x0, y = hh*j-y0;
					positions[0] = x; // point 0
					positions[1] = y;
					positions[2] = z;
					positions[3] = x + vx; // point 1
					positions[4] = y + vy;
					positions[5] = z;
					line.visible = true;
					line.material.color = new THREE.Color( col );
					line.geometry.attributes.position.needsUpdate = true;
				}
			}
			lines.visible = true;
		}
	}
	
	// -----------------------  m3js_vField2D function end
	
	
	// -----------------------  m3js_canvasSprite function  ------------------------------
	//
	//    ver 0.0.0  2022.05.06 created, last updated on 2022.12.19
	//
	// cnvsprite = m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight )
	//     spriteWidth: world width of sprite 3D object
	//     spriteHeight: world height of sprite 3D object
	//     canvasHeight: canvas height in pixel
	// scene.add( cnvsprite );
	//
	// cnvsprite.update( drawFunc )
	//     sprite: sprite object
	//     drawFunc: draw(sprite)
	// 
	// cnvsprite.visible = true | false;
	//
	
	function m3js_canvasSprite( spriteWidth, spriteHeight, canvasHeight ) {
		// canvas setup
		const canvasWidth = Math.ceil(spriteWidth*canvasHeight/spriteHeight);
		const canvas = document.createElement("canvas");
		canvas.width  = canvasWidth;
		canvas.height = canvasHeight;
		const ctx = canvas.getContext('2d');
		ctx.font = "16px 'sans-serif'";
		ctx.textBaseline = "bottom";
		ctx.textAlign = "left";
		
		// texture <-- canvas
		const texture = new THREE.Texture(canvas);
		texture.needsUpdate = true;
		
		// sprite <-- texture
		const spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
		const sprite = new THREE.Sprite( spriteMaterial );
		
		sprite.scale.set(spriteWidth, spriteHeight, 1);
		sprite.canvas = canvas;
		sprite.ctx = ctx;
		sprite.texture = texture;
		sprite.visible = false;
		sprite.update =
			function( drawFunc ) {
				drawFunc(sprite);
				sprite.visible = true;
				sprite.texture.needsUpdate = true;
			};
		return sprite;
	}
	
	// -----------------------  m3js_canvasSprite function end
	
	
	// ----------  dom control
	
	function initDom() {
		document.getElementById("step_button").style.visibility = "hidden";
	}
	
	function reset() {
		resetFlag = 1;
	}
	
	function pause() {
		let btn = document.getElementById("pause_button");

		pauseFlag = (pauseFlag+1)%2; 
		if (pauseFlag==0) btn.innerHTML = "pause"; else btn.innerHTML = "go";
		
		if ( pauseFlag==1 ) {
			document.getElementById("step_button").style.visibility = "visible";
		} else {
			document.getElementById("step_button").style.visibility = "hidden";
		}
	}
	
	function step() {
		stepFlag = 1;
	}
	
	function setTheme() {
		v_theme = 0 + document.getElementById("slct_theme").selectedIndex;
		resetFlag = 1;
	}
	
	function setSpeed() {
		v_nCalc = 1 + document.getElementById("slct_speed").selectedIndex;
	}
	
	function setDispMode() {  // select dispMode
		dispMode = 0 + document.getElementById("slct_dispMode").selectedIndex;
		dispModeChanged = true;
	}
	
	function viewHome() {
		viewHomeRequested = true;
	}
	
	
	//--------------------  public  --------------------
	
	return {
		main:			main,			// main()
		
		// dom control
		reset:			reset,			// reset()
		pause:			pause,			// pause()
		step:			step,			// step()
		
		setTheme:		setTheme,		// setTheme
		setSpeed:		setSpeed,		// setSpeed()
		setDispMode:	setDispMode,	// setDispMode()
		viewHome:		viewHome,		// viewHome()
	};
	
})(); //==============  tjs076 module end  =========================================================================


// event
const tjs = tjs076;
window.addEventListener('load', tjs.main );


//--------------------  end of javaScript

  </script>
  <style type="text/css">
    body { color:#000000; background-color:#fff8dd;}
  </style>
</head>

<body>
<p>[tjs076] air flows - lattice Boltzmann Method - 2D9V model</p>
<div style="position: relative; overflow: hidden; width: 500px; height: 480px">
  <canvas id="myCanvas" style="position: absolute; top: 0px; left: 0px"></canvas>
  <div id="textOnCanvas" 
    style="position:absolute; top:5px; left:5px; color:#99aa44; background-color:rgba(0, 0, 0, 0);
           font-size:0.9rem"> ... One moment, please.<br> ... setting up the studio ... </div>
</div>

<label>theme:</label>
<select id="slct_theme" onChange="tjs.setTheme()">
<option>gas expansion</option><option>gas expansion+object</option><option>vortex</option>
<option>Couette flow</option><option>cavity flow</option><option selected>wind tunnel(180x90)</option>
<option>wind tunnel(120x60)</option></select>
    <span style="margin-right: 130px;"></span>
<button onClick="tjs.reset()">reset</button>
    <span style="margin-right: 20px;"></span>
<button id="pause_button" onClick="tjs.pause()">pause</button>
    <span style="margin-right: 10px;"></span>
<button id="step_button" onClick="tjs.step()">step</button>
<br>

<label>disp mode:</label>
<select id="slct_dispMode" onChange="tjs.setDispMode()">
<option>density(x,y)</option><option selected>density(x,y) + powder</option>
<option>density(x,y) + vorticity(x,y)</option><option>density(x,y) + vorticity(x,y) + powder</option>
<option>(z:density(x,y)) + flow(x,y)</option>
<option>canvas2d flow(x,y)</option><option>canvas2d density(x,y) + flow(x,y)</option>
<option>canvas2d volticity(x,y) + flow(x,y)</option><option>canvas2d flow speed(x,y) + flow(x,y)</option>
<option>canvas2d powder</option><option>canvas2d density(x,y) + powder</option>
<option>canvas2d volticity(x,y) + powder</option><option>canvas2d flow speed(x,y) + powder</option>
</select>
    <span style="margin-right: 20px;"></span>
<label>nCalc/frame:</label>
<select id="slct_speed" onChange="tjs.setSpeed()">
<option>1</option><option>2</option><option>3</option><option selected>4</option>
<option>5</option><option>6</option><option>7</option><option>8</option>
<option>9</option><option>10</option>
</select>
<br>

<button onClick="tjs.viewHome()">return to initial view</button>
    <span style="margin-right: 20px;"></span>
drag mouse to rotate view point
<br>

<hr width="500" align="left" color="#a0a0a0">
<div id="text_caption" ></div>
<hr width="500" align="left" color="#a0a0a0">
<a href="javascript:history.back()">back</a> | <a href="http://mike1336.web.fc2.com/index.html">top</a>
<br>
</body>
</html>

